-- -*- coding: utf-8 -*-
------------------------------------------------------------------------------
-- Copyright 2006--2020 Sorin Popescu, Gregory G. Smith, and Mike Stillman
--
-- This program is free software: you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the Free
-- Software Foundation, either version 3 of the License, or (at your option)
-- any later version.
--
-- This program is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-- more details.
--
-- You should have received a copy of the GNU General Public License along
-- with this program.  If not, see <http://www.gnu.org/licenses/>.
------------------------------------------------------------------------------
-- Simplicial Complexes Documentation
------------------------------------------------------------------------------
doc ///  
    Key
        SimplicialComplexes
    Headline 
        data types and routines for working with simplicial complexes
    Description
        Text
            A simplicial complex on a set of vertices is a collection of
     	    subsets {\tt D} of these vertices such that if {\tt F} is in 
	    {\tt D} then every subset of {\tt F} is also in {\tt D}.  In this
     	    package, the vertices are variables in a polynomial ring and each
     	    subset is represented as a product of the corresponding variables.
    	Text     
            There is a bijection between simplicial complexes and squarefree
            monomial ideals.  This package exploits this correspondence by
            using commutative algebra routines to perform most of the
            necessary computations.
     	Text
     	    TODO: add some references?
	Text
            @SUBSECTION "Contributors"@
	Text
	    The following people have generously contributed code, improved existing code, or 
	    enhanced the documentation:  TODO
	Text
	    TODO: are there enought functions to subdivide the documentation in sections?
///

     
document {  Key => SimplicialComplex,
     TT "SimplicialComplex", " -- the class of simplical complexes",
     PARA{},
     "Some support routines",
     UL {
	  (TO "support", "(m) -- the support of the monomial m, as a list of integers")
	  }
     }
 
 
doc ///
    Key
        (dim, SimplicialComplex)
    Headline
        dimension of a simplicial complex
    Usage
        dim D
    Inputs
        D : SimplicialComplex
    Outputs
        : ZZ
	    the maximum number of vertices in a face minus one
    Description
        Text
            The following simplicial complex consists of a tetrahedron, with
     	    two triangles attached, two more edges, and an isolated vertex.
     	    Since the largest facet has $4$ vertices, this simplicial complex
     	    has dimension $3$.
     	Example
            R = ZZ[a..h];
	    D = simplicialComplex{a*b*c*d, a*b*e, c*d*f, f*g, g*a, h}
	    dim D
    	Text
            The void complex has dimension minus infinity, while the
     	    irrelevant complex has dimension $-1$.
     	Example
	    void = simplicialComplex monomialIdeal 1_R;
	    dim void
	    irrelevant = simplicialComplex {1_R};
	    dim irrelevant
    SeeAlso
        SimplicialComplex
	isPure
///


document { 
     Key => {simplicialComplex,(simplicialComplex,MonomialIdeal),
	  (simplicialComplex,List)},
     Headline => "create a simplicial complex",
     Usage => "simplicialComplex I\nsimplicialComplex L",
     Inputs => {
	  "I" => MonomialIdeal => "the ideal of minimal nonfaces (Stanley-Reisner ideal)",
	  "L" => List => "a list of monomials representing the facets"
          },
     Outputs => {
	  SimplicialComplex => {"the simplicial complex determined by the nonfaces ", TT "I", " 
	  or generated by the given faces ", TT "L"}
          },
     "A simplicial complex on a set of vertices 
     is a collection of subsets 
     ", TT "D", " of
     these vertices, such that if ", TT "F", " is in ", TT "D", ", 
     then every subset of ", TT "F", " is also in ", TT "D", ".
     In Macaulay2, the vertices are variables in a polynomial ring,
     and each subset is represented as a product of the
     corresponding variables.",
     PARA{},
     "A simplicial complex is determined either by its nonfaces or by its faces.
     The monomials corresponding to the nonfaces are a basis of an ideal,
     called the Stanley-Reisner ideal, and
     it suffices to specify the minimal nonfaces, which generate the ideal.
     The monomials corresponding to the faces do not form the basis of an ideal,
     but it suffices to specify the maximal faces, which are called 
     ", EM "facets", ".  The function ", TO "simplicialComplex", " accepts either
     the ideal of nonfaces or the list of facets as input.",
     PARA{},
     "In our first example we construct the octahedron by specfying its
     ideal of nonfaces.",
     EXAMPLE {
	  "R = ZZ[a..f];",
	  "I = monomialIdeal(a*f, b*d, c*e);",
	  "Octahedron = simplicialComplex I"
          },
     "Note that ", ofClass SimplicialComplex, " is displayed by showing its
     facets.  We see that there are eight facets to the octahedron.  Alternatively,
     we could have defined the octahedron by this list of facets.",
     EXAMPLE {
	  "L = {d*e*f, b*e*f, c*d*f, b*c*f, 
	       a*d*e, a*b*e, a*c*d, a*b*c}",
	  "Octahedron' = simplicialComplex L",
	  "Octahedron == Octahedron'",
	  "fVector Octahedron"
	  },
     "There are two \"trivial\" simplicial complexes: the void 
     complex and the irrelevant complex.  The void complex
     has no faces.  This complex cannot be constructed from
     its facets, since it has none.",
     EXAMPLE {
	  "void = simplicialComplex monomialIdeal 1_R",
	  "fVector void",
	  "dim void"
	  },
     "The irrelevant complex, which should be distinguished 
     from the void complex, has a unique face of dimension -1, 
     the empty set.",
     EXAMPLE {
	  "irrelevant = simplicialComplex monomialIdeal gens R",
	  "fVector irrelevant",
	  "dim irrelevant",
	  "irrelevant' = simplicialComplex {1_R}",
	  "irrelevant' == irrelevant"
	  },
     "As in Miller-Sturmfels, Combinatorial Commutative
     Algebra, we would avoid making such a big deal about 
     the difference between these complexes if it did not
     come up so much.  Many formulas for betti numbers, 
     dimensions of local cohomology, etc., depend on this
     distinction.",
     Caveat => UL {
	   {"The ring of ", TT "I", " or ", TT "L", 
		" must be a polynomial ring."},
	   {"The ", TO2(coefficientRing, "coefficient ring"),
	   " matters: for instance,
	   it is used when 
	   computing the corresponding chain complex."},
	   "This construction routine does some computation, as it
	   computes both the facets and the ideal of non-faces."
	   },
     SeeAlso => {SimplicialComplexes, fVector}
     }
 

document { 
     Key => boundary,
     Headline => "boundary operator",
     SeeAlso => {SimplicialComplexes}
     }
 
 
document { 
     Key => (boundary,ZZ,SimplicialComplex),
     Headline => "the boundary map from i-faces to (i-1)-faces",
     Usage => "M = boundary(i,D)",
     Inputs => {
	  "i",
	  "D"
          },
     Outputs => {
	  "M" => Matrix => {"the boundary map from ", TT "i", 
	       "-faces to ", TT "(i-1)", "-faces of ", TT "D"}
          },
     "The columns of the matrix ", TT "M", " are indexed by the ", TT "i", "-faces of
     ", TT "D", ", and the rows are indexed by the ", TT "(i-1)", "-faces, in the order
     given by ", TO faces, ".  ", TT "M", " is defined over the ", 
     TO2((coefficientRing,SimplicialComplex),"coefficient ring"), " of ", TT "D", ".",
     "The boundary maps for the standard 3-simplex, defined over ", TT "ZZ", ".",
     EXAMPLE {
	  "R = ZZ[a..d];",
	  "D = simplicialComplex {a*b*c*d}",
	  "boundary(0,D)",
	  "faces(0,D)",
          "boundary(1,D)",
	  "faces(1,D)",
	  "boundary(2,D)",
	  "faces(2,D)",
	  "boundary(3,D)",
	  "faces(3,D)",
	  "boundary(4,D)"
	  },
     "The boundary maps depend on the ",
     TO2((coefficientRing,SimplicialComplex),"coefficient ring"), 
     " as the following examples illustrate.",
     EXAMPLE {
	  "R = QQ[a..f];",
	  "D = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f);",
	  "boundary(1,D)",
	  "R' = ZZ/2[a..f];",
	  "D' = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f);",
	  "boundary(1,D')"
	  },
     SeeAlso => {SimplicialComplexes, (chainComplex,SimplicialComplex), faces}
     }
 
 
document { 
     Key => (boundary,SimplicialComplex),
     Headline => "the boundary simplicial complex of D",
     Usage => "boundary D",
     Inputs => {
	  "D"
          },
     Outputs => {
	  SimplicialComplex => {"the boundary simplicial complex, 
	   i.e. the subcomplex of ", TT "D", 
	   " consisting of all nonmaximal faces of ", TT "D"},
          },
     "The boundary of the standard 3-simplex is the 2-sphere.",
     EXAMPLE {
          "R = ZZ[a..d];",
          "simplex = simplicialComplex{a*b*c*d}",
	  "sphere = boundary simplex",
	  "fVector sphere",
	  "fVector simplex"  
	  },
     "Facets may be of different dimensions.",
     EXAMPLE {
          "R = ZZ[a..g];",
          "D = simplicialComplex{a*b*c,a*d,d*f,g*c,e,f*g}",
	  "E = boundary D",
	  "fVector D",
	  "fVector E"
	  },
     SeeAlso => {SimplicialComplexes, fVector, isPure, facets}
     }


document { 
     Key => {buchbergerComplex, (buchbergerComplex,List,Ring), (buchbergerComplex,MonomialIdeal)},
     Headline => "Buchberger complex of a monomial ideal",
     Usage => "buchbergerComplex(L,R)\nbuchbergerComplex I",
     -- Inputs => {
     --      },
     -- Outputs => {
     --      },
     -- Consequences => {
     --      },     
     -- "description",
     -- EXAMPLE {
     --      },
     -- Caveat => {},
 
     SeeAlso => {SimplicialComplexes}
     }


document { 
     Key => {lyubeznikComplex, (lyubeznikComplex,List,Ring), (lyubeznikComplex,MonomialIdeal)},
     Headline => "Simplicial complex supporting the Lyubeznik resolution of a  monomial ideal",
     Usage => "lyubeznikComplex(L,R)\nlyubeznikComplex I",
     -- Inputs => {
     --      },
     -- Outputs => {
     --      },
     -- Consequences => {
     --      },     
     -- "description",
     -- EXAMPLE {
     --      },
     -- Caveat => {},

     SeeAlso => {SimplicialComplexes}
     }

document { 
     Key => {superficialComplex, (superficialComplex,List,Ring), (superficialComplex,MonomialIdeal)},
     Headline => "Simplicial complex supporting a superficial resolution of a monomial ideal",
     Usage => "superficialComplex(L,R)\nsuperficialComplex I",
     -- Inputs => {
     --      },
     -- Outputs => {
     --      },
     -- Consequences => {
     --      },     
     -- "description",
     -- EXAMPLE {
     --      },
     -- Caveat => {},

     SeeAlso => {SimplicialComplexes}
     }




document { 
     Key => {isPure,(isPure,SimplicialComplex)},
     Headline => "whether the facets are equidimensional",
     Usage => "isPure D",
     Inputs => {
	  "D" => SimplicialComplex
          },
     Outputs => {
	  Boolean => {TO true, " if the facets of ", TT "D", " all have the same dimension, 
	       and ", TO false, " otherwise"}
          },
     EXAMPLE {
          "R = ZZ[a..f];",
	  "D = simplicialComplex {a*b*c, a*b*d, d*e*f} ",
	  "isPure D"
	  },
     EXAMPLE {
	  "E = simplicialComplex {a*b*c, b*d, d*e*f} ",
	  "isPure E"
          },
     SeeAlso => {SimplicialComplexes, (dim,SimplicialComplex),facets}
     }
 
document { 
     Key => (ring,SimplicialComplex),
     Usage => "R = ring D",
     Inputs => {
	  "D"
          },
     Outputs => {
	  "R" => PolynomialRing => {"the polynomial ring used to define ", TT "D"}
          },
     "The vertices of every simplicial complex are variables in the polynomial ring ", TT "R", ",
     and subsets of vertices, such as faces, are represented as squarefree monomials in ", TT "R", ".",
     EXAMPLE {
          "R = QQ[a..d];",
	  "D = simplicialComplex monomialIdeal(a*b*c*d);",
	  "ring D",
	  "coefficientRing D",
          "S = ZZ[w..z];",
	  "E = simplicialComplex monomialIdeal(w*x*y*z);",
	  "ring E",
	  "coefficientRing E"
          },
     PARA{},
     "There is a bijection between simplicial complexes and squarefree
     monomial ideals.  This package exploits this correspondence by
     using commutative algebra routines to perform most of the necessary
     computations.",
     Caveat => {"Some operations depend on the choice of ring, or its coefficient ring"},
     SeeAlso => {SimplicialComplexes, (coefficientRing, SimplicialComplex)}
     }
document { 
     Key => (coefficientRing,SimplicialComplex),
     Usage => "coefficientRing D",
     Inputs => {
	  "D"
          },
     Outputs => {
	  Ring => {"the coefficients of the defining ",
	       TO2((ring,SimplicialComplex),"polynomial ring"),
	       " of ", TT "D"}
          },
     EXAMPLE {
          "R = QQ[a..d];",
	  "D = simplicialComplex monomialIdeal(a*b*c*d);",
	  "ring D",
	  "coefficientRing D",
          "S = ZZ[w..z];",
	  "E = simplicialComplex monomialIdeal(w*x*y*z);",
	  "ring E",
	  "coefficientRing E"
          },
     "Some computations depend on the choice of coefficient ring, for example,
     the boundary maps and the chain complex of D.",
     EXAMPLE {
	  "chainComplex D",
	  "chainComplex E"
          },
     SeeAlso => {SimplicialComplexes, 
	  (ring,SimplicialComplex), 
	  (chainComplex,SimplicialComplex), 
	  boundary}
     }
document { 
     Key => {label, (label,SimplicialComplex,List)},
     Headline => "labels with monomials the faces of simplicial complex",
     -- Usage => "",
     -- Inputs => {
     --      },
     -- Outputs => {
     --      },
     -- Consequences => {
     --      },     
     -- "description",
     -- EXAMPLE {
     --      },
     -- Caveat => {},
     -- SeeAlso => {}
     }
document { 
     Key => {link,(link,SimplicialComplex,RingElement)},
     Headline => "link of a face in a simplicial complex",
     Usage => "link(D,f)",
     Inputs => {
	  "D" => SimplicialComplex,
	  "f" => RingElement => {"a monomial representing a face of the simplicial complex ", TT "D"}
          },
     Outputs => {
	  SimplicialComplex => {"the link of ", TT "f", " in ", TT "D"}
          },
     TEX "The link of a face $f$ in $D$ is the simplicial complex whose faces 
     are the subsets $g$ whose intersection
     with $f$ is empty, where $f \\cup g$ is a face of $D$.",
     EXAMPLE {
	  "R = QQ[x0,x1,x2,x3,x4,x5,x6];",
	  "D = simplicialComplex {x0*x1*x3, x1*x3*x4, x1*x2*x4, x2*x4*x5,
	       x2*x3*x5, x3*x5*x6, x3*x4*x6, x0*x4*x6,
	       x0*x4*x5, x0*x1*x5, x1*x5*x6, x1*x2*x6,
	       x0*x2*x6, x0*x2*x3}",
	  "link(D,x0)",
	  "link(D,x0*x2)"
	  },
     SeeAlso => {SimplicialComplexes
	  }
     }
document { 
     Key => (dual,SimplicialComplex),
     Headline => "the Alexander dual of a simplicial complex",
     Usage => "dual D",
     Inputs => {
	  "D"
          },
     Outputs => {
	  SimplicialComplex => {"the Alexander dual of ", TT "D"}
          },
     "The Alexander dual of ", TT "D", " is the simplicial complex
     whose faces are the complements of the nonfaces of ", TT "D", ".
     The Alexander dual of a square is the disjoint union of
     two edges.",
     EXAMPLE {
	  "R = ZZ[a..d];",
	  "D = simplicialComplex {a*b,b*c,c*d,d*a}",
          "dual D"
	  },
     PARA{},
     "The Alexander dual is homotopy equivalent to the complement of ", TT "D", " in the sphere generated
     by all of the variables in the ", TO2((ring,SimplicialComplex),"ring"),
     " of ", TT "D", ".  In particular, it depends on the number of variables.",
     EXAMPLE {
	  "R = ZZ[a..e]",
	  "E = simplicialComplex {a*b,b*c,c*d,d*a}",
          "dual E"
          },
     "The projective dimension of the face ring of D equals the
     regularity of the face ideal of the Alexander dual of D
     see e.g., Corollary 5.59 of Miller-Sturmfels, Combinatorial
     Commutative Algebra.",
     EXAMPLE {
	  "R = QQ[a..f];",
	  "D = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f)",
	  "A = dual D",
	  "pdim (R^1/(ideal D))",
	  "regularity ideal A"
	  },
     PARA{},
     "Alexander duality interchanges extremal betti numbers of the face ideals.
     Following example 3.2 in Bayer-Charalambous-Popescu, ", EM "Extremal betti
     numbers and applications to monomial ideals", ", we have ",
     EXAMPLE {
	  "R = QQ[x0,x1,x2,x3,x4,x5,x6];",
	  "D = simplicialComplex {x0*x1*x3, x1*x3*x4, x1*x2*x4, x2*x4*x5,
	       x2*x3*x5, x3*x5*x6, x3*x4*x6, x0*x4*x6,
	       x0*x4*x5, x0*x1*x5, x1*x5*x6, x1*x2*x6,
	       x0*x2*x6, x0*x2*x3}",
	  "I = ideal D",
	  "J = ideal dual D",
	  "betti res I",
	  "betti res J"
	  },
     SeeAlso => {SimplicialComplexes, (dual,MonomialIdeal)}
     }

///
-- Greg and Mike were working on this when Greg had to go home
-- 7/13/05  Good example though!
     "Hochster gives a formula relating the homology of the Alexander dual 
     to the betti numbers of the Stanley-Reisner ideal, see e.g., 
     Corollary 1.40 in
     Miller-Sturmfels, Combinatorial Commutative Algebra. ",
     EXAMPLE {
	  --R = QQ[a..f];
	  R = QQ[a..f, Degrees => {
                          {1, 1, 0, 0, 0, 0, 0}, 
                          {1, 0, 1, 0, 0, 0, 0}, 
                          {1, 0, 0, 1, 0, 0, 0}, 
			  {1, 0, 0, 0, 1, 0, 0}, 
			  {1, 0, 0, 0, 0, 1, 0}, 
			  {1, 0, 0, 0, 0, 0, 1}}]
	  oct = simplicialComplex monomialIdeal(a*b,c*d,e*f)
	  cube = dual oct
	  lk = (D,m) -> simplicialComplex monomialIdeal(ideal support m + ((ideal D):m));
	  F = link(oct,a)
	  rank HH_1(F)
	  C = res ideal cube
	  tally degrees C_3
	  checkHochster = (D,face) -> (
	       R := ring D;
	       face' := (product gens R) // face;
	       D' := dual D;
	       h := apply(0..dim D', i -> (
     	           rank HH_(i-1)(link(D',face'))));
	       C := res ideal D;
	       b := apply(0..dim D', i -> (
			 d := tally degrees C_(i+1);
			 if d#?(degree face) then d#(degree face) else 0));
	       (b,h))
          checkHochster(cube,b*d*e*f)
	  checkHochster(oct,a*c)
	  checkHochster(oct,a*b)
	  checkHochster(oct,c*d*e*f)
	  checkHochster(cube,a*b*c*d*e)
	  },
///

document { 
     Key => {faces,(faces,ZZ,SimplicialComplex)},
     Headline => "the i-faces of a simplicial complex ",
     Usage => "faces(i,D)",
     Inputs => {
	  "i" => ZZ => "the dimension of the faces",
	  "D" => SimplicialComplex
          },
     Outputs => {
	  Matrix => {"with one row, whose entries are squarefree
	       monomials representing the faces of dimension ", 
	       TT "i", " of ", TT "D"}
          },
     "In Macaulay2, every ", TO2(SimplicialComplex, "simplicial complex"),
     " is equipped with a polynomial ring, and the matrix of i-faces
     is defined over this ring.",
     PARA {
     	  "This triangulation of the real projective plane has 6
     	  vertices, 15 edges and 10 triangles."
	  },
     EXAMPLE {
	  "R = ZZ[a..f]",
	  "D = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,
	                                      b*c*d,b*d*e,b*e*f,c*d*f,c*e*f)",
          "faces(-1,D)",
	  "faces(0,D)",
	  "faces(1,D)",
	  "faces(2,D)",
	  "fVector D"
          },
     PARA{},
     "To avoid repeated computation, 
     the matrix of ", TT "i", "-faces is cached at ", 
     TT "D.cache.faces#i", ".
     This function will use this value if it has already been 
     computed.",
     SeeAlso => {SimplicialComplexes,
	  facets,
	  boundary,
	  fVector
	  }
     }

document { 
     Key => (ideal,SimplicialComplex),
     Headline => "the ideal of minimal nonfaces (the Stanley-Reisner ideal)",
     Usage => "ideal D",
     Inputs => {
	  "D"
          },
     Outputs => {
	  Ideal => {"which is generated by monomials representing
	  the minimal nonfaces of ", TT "D"}
          },
     "In Macaulay2, every ", TO2(SimplicialComplex, "simplicial complex"),
     " is equipped with a polynomial ring, and the Stanley-Reisner ideal
     is contained in this ring.",
     PARA {
     	  "The 3-dimensional sphere has a unique minimal nonface
     	  which corresponds to the interior."
	  },
     EXAMPLE {
	  "R = ZZ[a..e];",
	  "sphere = simplicialComplex {b*c*d*e,a*c*d*e,a*b*d*e,a*b*c*e,a*b*c*d}",
	  "ideal sphere"
	  },
     "The simplicial complex from example 1.8
     in Miller-Sturmfels, Combinatorial Commutative Algebra,
     consists of a triangle (on vertices ", TT "a,b,c", 
	  "), two edges connecting ", TT "c", " to ", TT "d", 
	  " and ", TT "b", " to ", TT "d", 
	  ", and an isolated vertex ", TT "e", ".",
     EXAMPLE {
	  "D = simplicialComplex {e, c*d, b*d, a*b*c}",
	  "ideal D"
	  },
     "There are six minimal nonfaces of ", TT "D", ".",
     PARA{},
     "This routine is identical to ", TO (monomialIdeal,SimplicialComplex),
     ", except for the ", TO2(Type,"type"), " of the output.",
     PARA{},
     "Note that no computatation is performed by this routine; all the
     computation was done while constructing the simplicial complex.",
     SeeAlso => {SimplicialComplexes, 
	  simplicialComplex, 
	  facets, 
	  (monomialIdeal,SimplicialComplex)}
     }
document { 
     Key => (monomialIdeal,SimplicialComplex),
     Headline => "the monomial ideal of minimal nonfaces (the Stanley-Reisner ideal)",
     Usage => "monomialIdeal D",
     Inputs => {
	  "D"
          },
     Outputs => {
	  MonomialIdeal => {"which is generated by monomials representing
	  the minimal nonfaces of ", TT "D"}
          },
     "In Macaulay2, every ", TO2(SimplicialComplex, "simplicial complex"),
     " is equipped with a polynomial ring, and the Stanley-Reisner ideal
     is contained in this ring.",
     PARA {
     	  "The 3-dimensional sphere has a unique minimal nonface
     	  which corresponds to the interior."
	  },
     EXAMPLE {
	  "R = ZZ[a..e];",
	  "sphere = simplicialComplex {b*c*d*e,a*c*d*e,a*b*d*e,a*b*c*e,a*b*c*d}",
	  "monomialIdeal sphere"
	  },
     "The simplicial complex from example 1.8
     in Miller-Sturmfels, Combinatorial Commutative Algebra,
     consists of a triangle (on vertices ", TT "a,b,c", 
	  "), two edges connecting ", TT "c", " to ", TT "d", 
	  " and ", TT "b", " to ", TT "d", 
	  ", and an isolated vertex ", TT "e", ".",
     EXAMPLE {
	  "D = simplicialComplex {e, c*d, b*d, a*b*c}",
	  "monomialIdeal D"
	  },
     "There are six minimal nonfaces of ", TT "D", ".",
     PARA{},
     "This routine is identical to ", TO (ideal,SimplicialComplex),
     ", except for the ", TO2(Type,"type"), " of the output.",
     PARA{},
     "Note that no computatation is performed by this routine; all the
     computation was done while constructing the simplicial complex.",
     SeeAlso => {SimplicialComplexes, 
	  simplicialComplex, 
	  facets, 
	  (ideal,SimplicialComplex)}
     }

document { 
     Key => {facets, (facets,SimplicialComplex)},
     Headline => "the facets of a simplicial complex",
     Usage => "facets D",
     Inputs => {
	  "D" => SimplicialComplex
          },
     Outputs => {
	  Matrix => {"with one row, whose entries are squarefree
	       monomials representing the facets (maximal faces) of ", TT "D"}
          },
     "In Macaulay2, every ", TO2(SimplicialComplex, "simplicial complex"),
     " is equipped with a polynomial ring, and the resulting matrix of facets
     is defined over this ring.",
     PARA {
     	  "The 3-dimensional sphere has a unique minimal nonface
     	  which corresponds to the interior."
	  },
     EXAMPLE {
	  "R = ZZ[a..e];",
	  "sphere = simplicialComplex monomialIdeal(a*b*c*d*e)",
	  "facets sphere"
	  },
     "The following ", TO faces, " generate a simplicial complex
     consisting of a triangle (on vertices ", TT "a,b,c", 
	  "), two edges connecting ", TT "c", " to ", TT "d", 
	  " and ", TT "b", " to ", TT "d",
	  ", and an isolated vertex ", TT "e", ".",
     EXAMPLE {
	  "D = simplicialComplex {e, c*d, b*d, a*b*c, a*b, c}",
	  "facets D"
	  },
     "There are four facets of ", TT "D", ".",
     PARA{},
     "Note that no computatation is performed by this routine; all the
     computation was done while constructing the simplicial complex.",
     PARA{},
     "A simplicial complex is displayed by listing its facets, and so this
     function is frequently unnecessary.",
     SeeAlso => {SimplicialComplexes, 
	  simplicialComplex, 
	  faces
	  }
     }


-------------------------------------------------------------
-------------------------------------------------------------
-- 20/07/2018 Lorenzo: new/modified documentation

document {
     Key => {skeleton,(skeleton,ZZ,SimplicialComplex)},
     Headline => "the n-skeleton of the simplicial complex D",
     Usage => "skeleton(n,D)",
     Inputs => {
      "i" => ZZ,
      "D" => SimplicialComplex
          },
     Outputs => {
      SimplicialComplex => {"the ", TT "n","-skeleton of a simplicial complex,
       i.e. the subcomplex of all subfaces of dimension at most ", TT "n"},
          },
     "The 2-skeleton of the 5-simplex.",
     EXAMPLE {
          "R = ZZ[a..f];",
          "simplex = simplicialComplex{a*b*c*d*e*f}",
      "skel = skeleton(2,simplex)",
      "fVector simplex",
      "fVector skel"
      },
     SeeAlso => {SimplicialComplexes, fVector, faces}
     }

document {
     Key => {fVector,(fVector,SimplicialComplex),[fVector,Flag]},
     Headline => "the f-vector of a simplicial complex",
     Usage => "f = fVector D",
     Inputs => {
      "D" => SimplicialComplex,
      Flag => Boolean => "the flag f-vector if the simplicial complex is properly defined over a multigraded ring."
          },
     Outputs => {
      "f" => {"such that ", TT "f#i",
      " is the number of faces in ", TT "D",
      " of dimension ", TT "i", " for ", TT "-1 <= i <= dim D", " or of squarefree degree ", TT "i."}
          },
     "The pentagonal bipyramid has 7 vertices, 15 edges
     and 10 triangles.",
     EXAMPLE {
      "R = ZZ[a..g];",
      "bipyramid = simplicialComplex monomialIdeal(
      a*g, b*d, b*e, c*e, c*f, d*f)",
      "f = fVector bipyramid",
      "f#0",
      "f#1",
      "f#2"
          },
     "Every simplicial complex other than the void
     complex has a unique face of dimension -1.",
     EXAMPLE {
      "void = simplicialComplex monomialIdeal 1_R",
      "fVector void"
      },
     "For a larger examp;le we consider the polarization
     of an artinian monomial ideal from section 3.2 in
     Miller-Sturmfels, Combinatorial Commutative Algebra.",
     EXAMPLE {
      "S = ZZ[x_1..x_4, y_1..y_4, z_1..z_4];",
      "I = monomialIdeal(x_1*x_2*x_3*x_4,
           y_1*y_2*y_3*y_4,
           z_1*z_2*z_3*z_4,
           x_1*x_2*x_3*y_1*y_2*z_1,
           x_1*y_1*y_2*y_3*z_1*z_2,
           x_1*x_2*y_1*z_1*z_2*z_3);",
          "D = simplicialComplex I;",
      "fVector D"
      },
      "The boundary of the 3-dimensional cross-polytope is
      3-colorable. If we define this simplicial complex over
      a ", TT "Z^3", "-graded ring we can ask for its flag
      f-vector.",
      EXAMPLE {
      "grading = {{1,0,0},{1,0,0},{0,1,0},{0,1,0},{0,0,1},{0,0,1}};",
      "S = ZZ[x_1..x_6, Degrees => grading];",
      "I = monomialIdeal(x_1*x_2,x_3*x_4,x_5*x_6);",
      "fVector simplicialComplex I",
      "fVector(simplicialComplex I, Flag => true)"
      },
     Caveat => {
     "The option ", TT "Flag", " checks if the multigrading corresponds to a properly d-coloring of "
     , TT "D", ", where d is the dimension of ", TT "D", " plus one. If it is not the case the output
     is an empty HashTable."
     },
     PARA{},
     "The f-vector is computed using the Hilbert series
     of the Stanley-Reisner ideal.  For example, see
     Hosten and Smith's
     chapter Monomial Ideals, in Computations in
     Algebraic Geometry with Macaulay2, Springer 2001.",
     SeeAlso => {SimplicialComplexes,
      faces}
     }

--These are documented in the above node.
undocumented { "Flag" }


document {
     Key => {algebraicShifting,(algebraicShifting,SimplicialComplex),[algebraicShifting,Multigrading]},
     Headline => "the algebraic shifting of a simplicial complex",
     Usage => "A = algebraicShifting D",
     Inputs => {
     "D" => SimplicialComplex,
     Multigrading => Boolean => "If true it returns the colored algebraic shifting w.r.t. the multigrading of the underlying ring."
          },
     Outputs => {
     "A" => {"The algebraic shifting of the simplicial complex ", TT "D", ". If ", TT "Multigrading => true", " then it returns the so called colored shifted complex."}
          },
     "The boundary of the stacked 4-polytope on 6 vertices. Algebraic shifting preserves the f-vector.",
     EXAMPLE {
      "R=QQ[x_1..x_6];",
      "I=monomialIdeal(x_2*x_3*x_4*x_5,x_1*x_6);",
      "stacked = simplicialComplex(I)",
      "shifted = algebraicShifting(stacked)",
      "fVector stacked",
      "fVector shifted"
          },
     "An empty triangle is a shifted complex.",
     EXAMPLE {
     "R=QQ[a,b,c];",
     "triangle = simplicialComplex{a*b,b*c,a*c};",
     "algebraicShifting(triangle) == triangle "
     },
     "The multigraded algebraic shifting does not preserve the Betti numbers.",
     EXAMPLE {
      "grading = {{1,0,0},{1,0,0},{1,0,0},{0,1,0},{0,0,1}};",
      "R=QQ[x_{1,1},x_{1,2},x_{1,3},x_{2,1},x_{3,1}, Degrees=>grading];",
      "delta = simplicialComplex({x_{1,3}*x_{2,1}*x_{3,1},x_{1,1}*x_{2,1},x_{1,2}*x_{3,1}})",
      "shifted = algebraicShifting(delta, Multigrading => true)",
      "prune (homology(delta))_1",
      "prune (homology(shifted))_1"
     },
     "References:",
     PARA {},
     "G. Kalai, Algebraic Shifting, Computational Commutative Algebra and Combinatorics, 2001;",
      PARA {},
     "S. Murai, Betti numbers of strongly color-stable ideals and squarefree strongly color-stable ideals, Journal of Algebraic Combinatorics."
     }

--These are documented in the above node.
undocumented { "Multigrading" }

document {
     Key => {star,(star,SimplicialComplex,RingElement)},
     Headline => "star of a face in a simplicial complex",
     Usage => "star(D,f)",
     Inputs => {
      "D" => SimplicialComplex,
      "f" => RingElement => {"a monomial representing a face of the simplicial complex ", TT "D"}
          },
     Outputs => {
      SimplicialComplex => {"the star of ", TT "f", " in ", TT "D"}
          },
     TEX "The star of a face $f$ in $D$ is the simplicial complex whose faces
     are the subsets $g$ with $f \\cup g$ is a face of $D$.",
     PARA {},
     " The bow-tie complex.",
     EXAMPLE {
      "R = QQ[x_1..x_5];",
      "bowtie = simplicialComplex {x_1*x_2*x_3,x_3*x_4*x_5}",
      "star(bowtie,x_3)",
      "star(bowtie,x_1*x_2)"
      },
     PARA {},
     " The 3-simplex and a copy of its boundary glued along a triangle.",
     EXAMPLE {
      "R = QQ[a..e];",
      "D = simplicialComplex {a*b*c*d, b*c*e, b*d*e, c*d*e}",
      "star(D,b*c*d)",
      "star(D,b)"
      },
     SeeAlso => {SimplicialComplexes, link
      }
     }

document {
     Key => {joinSimplicial,(joinSimplicial,SimplicialComplex,SimplicialComplex)},
     Headline => "the join of two simplicial complexes",
     Usage => "joinSimplicial(D,E)",
     Inputs => {
      "D" => SimplicialComplex,
      "E" => SimplicialComplex
          },
     Outputs => {
      SimplicialComplex => {"the join of ", TT "D", " and ", TT "E"}
          },
     TEX "The join of two simplicial complexes $D$ and $E$ is the simplicial complex whose faces
     are the union of faces of $D$ and $E$. If $D$ is the simplicial complex consisting of a
     single vertex then the join is the cone over $E$. If $D$ consists of two isolated vertices
     then the join is the suspension of $E$.",
     PARA {},
     " The cone over a bow-tie complex.",
     EXAMPLE {
      "R = QQ[x_1..x_5];",
      "bowtie = simplicialComplex {x_1*x_2*x_3, x_3*x_4*x_5};",
      "S = QQ[v];",
      "singleton = simplicialComplex {v};",
      "singleton * bowtie"
      },
     PARA {},
     " The octahedron is the suspension of a square.",
     EXAMPLE {
      "R = QQ[a..d];",
      "square = simplicialComplex {a*b, b*c, c*d, a*d};",
      "S = QQ[p,q];",
      "poles = simplicialComplex {p, q};",
      "octahedron = joinSimplicial(poles,square)"
      },
      PARA {},
      " The join of an exagon and a pentagon.",
      EXAMPLE {
      "R = ZZ[x_1..x_6];",
      "exagon = simplicialComplex {x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_5,x_5*x_6,x_1*x_6};",
      "S = ZZ[y_1..y_5];",
      "pentagon = simplicialComplex {y_1*y_2,y_2*y_3,y_3*y_4,y_4*y_5,y_1*y_5};",
      "sphere = joinSimplicial(exagon,pentagon)",
      "fVector(sphere)"
      },
      Caveat => {
      "The two simplicial complexes have to be defined over different polynomial rings."
      },
      SeeAlso => {SimplicialComplexes, (symbol *,SimplicialComplex,SimplicialComplex)
      }
     }

document {
     Key => (symbol *,SimplicialComplex,SimplicialComplex),
     Headline => "the join of two simplicial complexes",
     Usage => "  J = D * E",
     Inputs => {
      "D" => SimplicialComplex,
      "E" => SimplicialComplex
      },
     Outputs => {
      "J" => SimplicialComplex
      },

     PARA{}, "Computes join of ",TT "D"," and ",TT "E",".",

     PARA{}, "See also ",TO joinSimplicial,".",

     }



doc ///
  Key
    Face
  Headline
   The class of faces of simplicial complexes.
  Description
   Text
        The class of faces of simplicial complexes on the variables of a polynomial ring.
        The faces are @TO MutableHashTable@s F with two @TO keys@
        
        F.vertices is a @TO List@ of vertices in the @TO PolynomialRing@ F.ring

   Example
     R=QQ[x_0..x_4];
     F=face {x_0,x_2}
     I=monomialIdeal(x_0*x_1,x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_0);
     D=simplicialComplex I
     fc=faces(1,D,useFaceClass=>true)
     select(fc,j->j==F)
  SeeAlso
     SimplicialComplex
     faces
     facets
///


doc ///
  Key
    (symbol ==,Face,Face)
  Headline
   Compare two faces.
  Usage
    F==G
  Inputs
    F:Face
    G:Face
  Outputs
    :Boolean
  Description
   Text
        Checks whether F and G are equal.

   Example
     K=QQ;
     R=K[x_0..x_4];
     F=face {x_0,x_1}
     G1=face {x_1,x_0}
     G2=face {x_1,x_2}
     F==G1
     F==G2
  SeeAlso
     Face
     face
///


doc ///
  Key
    face
    (face,List)
    (face,List,PolynomialRing)
    (face,RingElement)
  Headline
    Generate a face.
  Usage
    face(L)
    face(L,R)
    face(m)
  Inputs
    L:List
    R:PolynomialRing
    m:RingElement
        a monomial
  Outputs
    :Face
  Description
   Text
        Generates a face out of a list L or a squarefree monomial.
        If L is not empty or a monomial the argument R is not required.

   Example
     K=QQ;
     R=K[x_0..x_4];
     F=face {x_0,x_1}
  SeeAlso
     SimplicialComplex
     faces
     facets
///

doc ///
  Key
    (dim,Face)
  Headline
    The dimension of a face.
  Usage
    dimension(F)
  Inputs
    F:Face
  Outputs
    :ZZ
      bigger or equal to -1
  Description
   Text
        Returns the dimension of a @TO Face@, i.e., the number of @TO vertices@ F minus 1.

   Example
     K=QQ;
     R=K[x_0..x_4];
     I=monomialIdeal(x_0*x_1,x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_0);
     D=simplicialComplex I
     fc=faces(D,useFaceClass=>true)
     apply(-1..1, j->apply(fc#j,dim))
  SeeAlso
     face
     facets
     faces
///

doc ///
  Key
    vertices
    (vertices,Face)
  Headline
    The vertices of a face of a simplicial complex.
  Usage
    vertices(F)
  Inputs
    F:Face
  Outputs
    :List
  Description
   Text
        Returns a @TO List@ with the vertices of a @TO Face@ of a simplicial complex.

   Example
     K=QQ;
     R=K[x_0..x_4];
     I=monomialIdeal(x_0*x_1,x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_0);
     D=simplicialComplex I
     fc=facets(D,useFaceClass=>true)
     vertices fc#1
  SeeAlso
     face
     facets
     faces
///

doc ///
  Key
    isSubface
    (isSubface,Face,Face)
  Headline
    Test whether a face is a subface of another face.
  Usage
    isSubface(F,G)
  Inputs
    F:Face
    G:Face
  Outputs
    :Boolean
  Description
   Text
        Test whether F is a subface of G.

   Example
     K=QQ;
     R=K[x_0..x_4];
     G=face {x_0,x_1,x_2}
     F1=face {x_0,x_2}
     F2=face {x_0,x_3}
     isSubface(F1,G)
     isSubface(F2,G)
///

doc ///
  Key
    (substitute,Face,PolynomialRing)
  Headline
    Substitute a face to a different ring.
  Usage
    substituteFace(F,R)
  Inputs
    F:Face
    R:PolynomialRing
  Outputs
    :Face
  Description
   Text
        Substitute a face to a different ring.

   Example
     K=QQ;
     R=K[x_0..x_4];
     F=face {x_0,x_1,x_2}
     S=R**K[y]
     substitute(F,S)
///

doc ///
  Key
    (ring,Face)
  Headline
    Ring of a face.
  Usage
    ring(F)
  Inputs
    F:Face
  Outputs
    :Ring
  Description
   Text
        Ring of a face.

   Example
     K=QQ;
     R=K[x_0..x_4];
     F=face {x_0,x_1,x_2}
     ring F
///


doc ///
  Key
    (substitute,SimplicialComplex,PolynomialRing)
  Headline
    Substitute a simplicial complex to a different ring.
  Usage
    substitute(C,R)
  Inputs
    C:SimplicialComplex
    R:PolynomialRing
  Outputs
    :SimplicialComplex
  Description
   Text
        Substitute a simplicial complex to a different ring. R should contain the variables of the @TO ring@ of C.

   Example
     K=QQ;
     R=K[x_0..x_4];
     I=monomialIdeal(x_0*x_1,x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_0);
     C=simplicialComplex I
     S=R**K[y]
     C1=substitute(C,S)
     ring C1
  SeeAlso
     (substitute,Face,PolynomialRing)
///

doc ///
  Key
    isFaceOf
    (isFaceOf,Face,SimplicialComplex)
  Headline
    Substitute a face to a different ring.
  Usage
    substitute(F,R)
  Inputs
    F:Face
    R:PolynomialRing
  Outputs
    :Face
  Description
   Text
        Substitute a face to a different ring.

   Example
     K=QQ;
     R=K[x_1..x_5];
     C=simplicialComplex monomialIdeal (x_1*x_2,x_3*x_4*x_5)
     F1=face {x_1,x_2}
     F2=face {x_1,x_3}
     isFaceOf(F1,C)
     isFaceOf(F2,C)
///

doc ///
  Key
    (net,Face)
  Headline
    Printing a face.
  Usage
    net(F)
  Inputs
    F:Face
  Outputs
    :Net
  Description
   Text
        Prints a face. The vertices are printed without any brackets and with one space between them. Also prints the polynomial ring which contains the vertices.

   Example
     K=QQ;
     R=K[x_0..x_4];
     face {x_0,x_1}
///

doc ///
  Key
    useFaceClass
    [faces,useFaceClass]
    [facets,useFaceClass]
  Headline
    Option to return faces in the class Face
  Description
   Text
    @TO Boolean@ @TO Option@ to return in the methods @TO faces@ and @TO facets@ a @TO List@ of @TO Face@s instead of a @TO Matrix@.
///

doc ///
  Key
    (faces,SimplicialComplex)
  Headline
    Compute all faces of a simplicial complex.
  Usage
    faces(C)
  Inputs
    C:SimplicialComplex
  Outputs
    :MutableHashTable
  Description
   Text
        Return a list of lists of the faces of a simplicial complex.

   Example
    K=QQ;
    R=K[x_1..x_5];
    C=simplicialComplex monomialIdeal (x_1*x_2,x_3*x_4*x_5)
    fc=faces(C,useFaceClass=>true)
    fc#2
 ///


-------------------------------------------------------------------
-- some previously missing documentation

doc ///
  Key
    (net,SimplicialComplex)
  Headline
    Printing a simplicial complex.
  Usage
    net(C)
  Inputs
    C:SimplicialComplex
  Outputs
    :Net
  Description
   Text
        Prints a simplicial complex. 

   Example
    K=QQ;
    R=K[x_1..x_5];
    C=simplicialComplex monomialIdeal (x_1*x_2,x_3*x_4*x_5)
///

doc ///
  Key
    (symbol ==,SimplicialComplex,SimplicialComplex)
  Headline
   Compare two simplicial complexes.
  Usage
    C1==C2
  Inputs
    C1:SimplicialComplex
    C2:SimplicialComplex
  Outputs
    :Boolean
  Description
   Text
        Checks whether C1 and C2 are equal.

   Example
    K=QQ;
    R=K[x_1..x_3];
    C1=simplicialComplex monomialIdeal (x_1*x_2*x_3)
    C2=simplicialComplex {face {x_1,x_2},face {x_2,x_3},face {x_3,x_1}}
    C1==C2
///


doc ///
  Key    
    (chainComplex,SimplicialComplex)
    simplicialChainComplex
    (simplicialChainComplex,List,SimplicialComplex)
  Headline
    The chain complex of boundary maps.
  Usage
    chainComplex C
  Inputs
    C:SimplicialComplex
  Outputs
    :ChainComplex
  Description
   Text
     The @TO ChainComplex@ of @TO boundary@ maps from i-faces to (i-1)-faces.

   Example
    R = QQ[a..f];
    D = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f);
    R' = ZZ/2[a..f];
    D' = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f);
    c = chainComplex D
    c' = chainComplex D'
    c.dd_1
    c'.dd_1
  SeeAlso
   boundary
///


doc ///
  Key    
    (homology,ZZ,SimplicialComplex)
  Headline
    Compute the homology of a simplicial complex.
  Usage
    homology(j,C)
  Inputs
    j:ZZ
    C:SimplicialComplex
  Outputs
    :Module
  Description
   Text
     Compute the j-th reduced homology of C with coefficients in @TO (coefficientRing,SimplicialComplex)@ C.

   Example
    R=ZZ[x_0..x_5];
    D=simplicialComplex apply({{x_0, x_1, x_2}, {x_1, x_2, x_3}, {x_0, x_1, x_4}, {x_0, x_3, x_4}, {x_2, x_3, x_4}, {x_0, x_2, x_5}, {x_0, x_3, x_5}, {x_1, x_3, x_5}, {x_1, x_4, x_5}, {x_2, x_4, x_5}},face)
    prune homology(1,D)
  SeeAlso
    (homology,ZZ,SimplicialComplex,Ring)
   boundary
   (chainComplex,SimplicialComplex)
///

doc ///
  Key    
    (homology,ZZ,SimplicialComplex,Ring)
  Headline
    Compute the homology of a simplicial complex.
  Usage
    homology(j,C,R)
  Inputs
    j:ZZ
    C:SimplicialComplex
    R:Ring
  Outputs
    :Module
  Description
   Text
     Compute the j-th reduced homology of C with coefficients in R.

   Example
    R=ZZ[x_0..x_5];
    D=simplicialComplex apply({{x_0, x_1, x_2}, {x_1, x_2, x_3}, {x_0, x_1, x_4}, {x_0, x_3, x_4}, {x_2, x_3, x_4}, {x_0, x_2, x_5}, {x_0, x_3, x_5}, {x_1, x_3, x_5}, {x_1, x_4, x_5}, {x_2, x_4, x_5}},face)
    prune homology(1,D,ZZ)
    prune homology(1,D,QQ)
    prune homology(1,D,ZZ/2)
  SeeAlso
    (homology,ZZ,SimplicialComplex)
   boundary
   (chainComplex,SimplicialComplex)
///

doc ///
  Key    
    (homology,SimplicialComplex,Ring)
    (homology,Nothing,SimplicialComplex,Ring)
  Headline
    Compute the homology of a simplicial complex.
  Usage
    homology(C,R)
  Inputs
    C:SimplicialComplex
    R:Ring
  Outputs
    :GradedModule
  Description
   Text
     The graded module of reduced homologies of C with coefficients in R.

   Example
    R=ZZ[x_0..x_5];
    D=simplicialComplex apply({{x_0, x_1, x_2}, {x_1, x_2, x_3}, {x_0, x_1, x_4}, {x_0, x_3, x_4}, {x_2, x_3, x_4}, {x_0, x_2, x_5}, {x_0, x_3, x_5}, {x_1, x_3, x_5}, {x_1, x_4, x_5}, {x_2, x_4, x_5}},face)
    homology(D)
    homology(D,QQ)
    homology(D,ZZ/2)
  SeeAlso
    (homology,SimplicialComplex)
    (homology,ZZ,SimplicialComplex)
    (homology,ZZ,SimplicialComplex,Ring)
///

doc ///
  Key    
    (homology,SimplicialComplex)
    (homology,Nothing,SimplicialComplex)
  Headline
    Compute the homology of a simplicial complex.
  Usage
    homology C
  Inputs
    C:SimplicialComplex
  Outputs
    :GradedModule
  Description
   Text
     The graded module of reduced homologies of C with coefficients in R.

   Example
    R=ZZ[x_0..x_5];
    D=simplicialComplex apply({{x_0, x_1, x_2}, {x_1, x_2, x_3}, {x_0, x_1, x_4}, {x_0, x_3, x_4}, {x_2, x_3, x_4}, {x_0, x_2, x_5}, {x_0, x_3, x_5}, {x_1, x_3, x_5}, {x_1, x_4, x_5}, {x_2, x_4, x_5}},face)
    homology D
  SeeAlso
    (homology,SimplicialComplex,Ring)
    (homology,ZZ,SimplicialComplex)
    (homology,ZZ,SimplicialComplex,Ring)
///
