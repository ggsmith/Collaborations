-- -*- coding: utf-8 -*-
------------------------------------------------------------------------------
-- Copyright 2006--2020 Sorin Popescu, Gregory G. Smith, and Mike Stillman
--
-- This program is free software: you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by the Free
-- Software Foundation, either version 3 of the License, or (at your option)
-- any later version.
--
-- This program is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-- more details.
--
-- You should have received a copy of the GNU General Public License along
-- with this program.  If not, see <http://www.gnu.org/licenses/>.
------------------------------------------------------------------------------
-- Simplicial Complexes Documentation
------------------------------------------------------------------------------
undocumented {
    (expression, SimplicialComplex)
    }

doc ///  
    Key
        SimplicialComplexes
    Headline 
        routines for working with abstract simplicial complexes
    Description
        Text
	    An @HREF("https://en.wikipedia.org/wiki/Abstract_simplicial_complex", 
		    "abstract simplicial complex")@  
	    is a family of finite sets closed under the operation of
	    taking subsets.
	Text
	    In this package, the finite set consists of variables in a
	    @TO2(PolynomialRing, "polynomial ring")@ and each subset is
	    represented as a product of the corresponding variables.  In other
	    words, we exploit the natural bijection between abstract
	    simplicial complexes and 
	     @HREF("https://en.wikipedia.org/wiki/Stanley–Reisner_ring",
	    "Stanley-Reisner ideals")@.
     	Text
     	    Introductions to the theory of abstract simplicial complexes that
     	    emphasize the connections with commutative algebra can be found in
     	    the following textbooks:
    	Text
	    @UL {
	    	{"Winfried Bruns and Jürgen Herzog, ",
		HREF("https://www.cambridge.org/core/books/cohenmacaulay-rings/938BC2204D8A7C99E2CEBA1695A692A4",
		    "Cohen-Macaulay rings"), 
		", Cambridge Studies in Advanced Mathematics 39,", 
		"Cambridge University Press, Cambridge, 1993. ",
		"ISBN: 0-521-41068-1" },
	    	{"Ezra Miller and Bernd Sturmfels, ",
		HREF("https://www.springer.com/gp/book/9780387223568",
		    "Combinatorial commutative algebra"),
		", Graduate Texts in Mathematics 227, ",
		"Springer-Verlag, New York, 2005. ",
		"ISBN: 0-387-22356-8" }, 
		{"Richard Stanley, ",
		HREF("https://www.springer.com/gp/book/9780817643690", 
		    "Combinatorics and commutative algebra"),
		", Progress in Mathematics 41, ",
		"Birkhäuser Boston, Inc., Boston, MA, 1983. ",
		"ISBN: 0-8176-3112-7" }
	    }@		
	Text
            @SUBSECTION "Contributors"@
	Text
	    The following people have generously contributed code, improved existing code, or 
	    enhanced the documentation:  
	    @HREF("https://www.mathematik.uni-kl.de/~boehm/", "Janko Böhm")@,
	    @HREF("https://www.math.stonybrook.edu/~sorin/", "Sorin Popescu")@,
	    @HREF("http://www.math.cornell.edu/~mike/","Mike Stillman")@, and
	    @HREF("https://www.mis.mpg.de/nlalg/nlalg-people/lorenzo-venturello.html", "Lorenzo Venturello")@.
    SeeAlso
        "making an abstract simplicial complex"
	"finding attributes and properties"
///
 
 
------------------------------------------------------------------------------
-- Basic features of the simplicial complex datatype
------------------------------------------------------------------------------
doc ///
    Key 
        "making an abstract simplicial complex"
    Headline
        information about the basic constructors
    Description
        Text
	    An {\em abstract simplicial complex} on the finite set is a family
	    of subsets that is closed under taking subsets.  The elements in
	    the abstract simplicial complex are called its {\em faces}.  The
	    faces having cardinality $1$ are its {\em vertices} and the
	    maximal faces (order by inclusion) are its {\em facets}.
	Text 
	    In this package, an abstract simplicial complex is represented by
	    its @HREF("https://en.wikipedia.org/wiki/Stanley–Reisner_ring",
	    "Stanley-Reisner ideal")@ in the polynomial ring.  More precisely,
	    the vertices are identified with a subset of the variables in a
	    fixed polynomial ring and each face is identify with the product
	    of the corresponding variables. A {\em nonface} is any subset of
	    the variables that does not belong to the abstract simplicial
	    complex—we also identify each nonface with a product of variables.
	    The Stanley-Reisner ideal of an abstract simplicial complex is
	    generated by monomials corresponding to its nonfaces.
    	Text
    	    @SUBSECTION "Constuctors for abstract simplicial complexes"@
	Text
    	    @UL {
                TO (simplicialComplex, List),		
                TO (simplicialComplex, MonomialIdeal),
        	TO SimplicialComplex,
		TO (dual, SimplicialComplex),
		TO (boundary, SimplicialComplex),
		TO (link, SimplicialComplex, RingElement),
		TO (skeleton, ZZ, SimplicialComplex),
		TO (star, SimplicialComplex, RingElement)
    	    }@
    SeeAlso
        "finding attributes and properties"
///

       
doc ///
    Key 
        SimplicialComplex
    Headline 
        the class of all abstract simplicial complexes
    Description
        Text
	    An {\bf abstract simplicial complex} on the finite set is a family
	    of subsets that is closed under taking subsets.  The elements in
	    the abstract simplicial complex are called its {\bf faces}.  The
	    faces having cardinality $1$ are its {\bf vertices} and the
	    maximal faces (order by inclusion) are its {\bf facets}.
	Text 
	    In this package, an abstract simplicial complex is represented by
	    its @HREF("https://en.wikipedia.org/wiki/Stanley–Reisner_ring",
	    "Stanley-Reisner ideal")@ in the polynomial ring.  More precisely,
	    the vertices are identified with a subset of the variables in a
	    fixed polynomial ring and each face is identify with the product
	    of the corresponding variables. A {\bf nonface} is any subset of
	    the variables that does not belong to the abstract simplicial
	    complex—we also identify each nonface with a product of variables.
	    The Stanley-Reisner ideal of an abstract simplicial complex is
	    generated by monomials corresponding to its nonfaces.
///


doc ///
    Key
        (facets, SimplicialComplex)
    Headline
        get the matrix of maximal faces 
    Usage
        facets D
    Inputs
	D : SimplicialComplex
    Outputs
	: Matrix 
	    that has one row whose entries are the squarefree monomials
	    representing the facets in {\tt D}
    Description
        Text
	    In this package, an abstract simplicial complex is constructed as
            squarefree monomial ideal in a 
	    @TO2((ring, SimplicialComplex), "polynomial ring")@.  The vertices
	    in the abstract simplicial complex are identified with a subset of
	    the variables in the polynomial ring and each face is identified
	    with the product of the corresponding variables.  This method
	    returns a matrix whose entries are the squarefree monomials
	    representing the maximal faces in the abstract simplicial complex.
	Text
	    The matrix has one row and the order of the columns is determined
	    by the @TO2(MonomialOrder, "monomial order")@ on the underlying
	    polynomial ring.  The facets of an abstract simplicial complex are
	    used when outputing or printing; see @TO (net, SimplicialComplex)@.
	Text
     	    The @HREF("https://en.wikipedia.org/wiki/5-cell", "4-simplex")@
     	    is a simplicial sphere with $5$ vertices, a minimal nonface
     	    that corresponds to the interior of the sphere, and 5 facets.
    	Example
	    S = ZZ[a..e];
	    D = simplicialComplex monomialIdeal (a*b*c*d*e)
	    facets D
	    assert (facets D == matrix{{b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}}
		and isPure D and dim D === 3)
    	Text
	    The abstract simplicial complex from Example 1.8 of
            Miller-Sturmfels' {\em Combinatorial Commutative Algebra} consists
            of a triangle (on vertices {\tt a, b, c}), two edges (connecting
            {\tt c} to {\tt d} and {\tt b} to {\tt d}), and an isolated
            vertex (namely {\tt e}).  It has six minimal nonfaces.
    	Example
	    D' = simplicialComplex {e, c*d, b*d, a*b*c}
	    facets D'
	    assert (facets D' == matrix {{e, c*d, b*d, a*b*c}} and 
		ideal D' == ideal (a*d, b*c*d, a*e, b*e, c*e, d*e) and 
		not isPure D' and dim D' === 2)
	Text
	    The irrelevant complex has the empty set as a facet whereas the
	    void complex has no facets.
	Example
	    irrelevant = simplicialComplex {1_S}
	    facets irrelevant
	    void = simplicialComplex monomialIdeal 1_S
	    facets void	    
	    assert (facets irrelevant == matrix{{1_S}} and facets void == 0)
    	Text
	    The matrix of facets is part of the defining data of an
	    abstract simplicial complex, so this method does no computation.
    SeeAlso 
	(net, SimplicialComplex)
	(ring, SimplicialComplex)
	(dim, SimplicialComplex)	
	(isPure, SimplicialComplex)	
	(faces, SimplicialComplex)
///


doc ///
    Key
        (net, SimplicialComplex)
    Headline
        make a symbolic representation of an abstract simplicial complex
    Usage
        net D
    Inputs
        D : SimplicialComplex
    Outputs
        : Net
	    a symbolic representation used for printing
    Description
        Text
	    The net of an abstract simplicial complex is a matrix with one row
	    where the entries are the monomials representing the facets (also
	    known as maximal faces).  This function is the primary function
	    called upon by @TO (symbol <<, File, Thing)@ to format for printing.
        Example
            S = ZZ[a..f];
	    Octahedron = simplicialComplex monomialIdeal(a*f, b*d, c*e)
    	    net Octahedron
	Text
	    The void complex has no facets whereas the irrelevant complex has
	    the empty set as a facet.
	Example
	    void = simplicialComplex monomialIdeal 1_S
	    net void
	    irrelevant = simplicialComplex {1_S};
	    net irrelevant
    SeeAlso
        (facets, SimplicialComplex)
///


doc /// 
    Key
        (ideal, SimplicialComplex)
    Headline 
        get the Stanley-Reisner ideal 
    Usage
        ideal D
    Inputs
	D : SimplicialComplex
    Outputs 
        : Ideal 
	    that is generated by the monomials representing the minimal
	    nonfaces in {\tt D}
    Description
        Text
            In this package, an abstract simplicial complex is constructed as
            squarefree monomial ideal in a 
	    @TO2((ring, SimplicialComplex), "polynomial ring")@.  This method
            returns the defining ideal.
	Text
     	    The @HREF("https://en.wikipedia.org/wiki/5-cell", "4-simplex")@
     	    is a simplicial sphere with $5$ vertices and a minimal nonface
     	    that corresponds to the interior of the sphere.	    
    	Example
	    S = ZZ[a..e];
	    D = simplicialComplex {b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}
	    I = ideal D
	    dim D
	    assert (I == ideal a*b*c*d*e and instance(I, Ideal) and 
		numgens I === 1 and dim D === 3)
    	Text
	    The abstract simplicial complex from Example 1.8 of
            Miller-Sturmfels' {\em Combinatorial Commutative Algebra} consists
            of a triangle (on vertices {\tt a, b, c}), two edges (connecting
            {\tt c} to {\tt d} and {\tt b} to {\tt d}), and an isolated
            vertex (namely {\tt e}).  It has six minimal nonfaces.
    	Example
	    D' = simplicialComplex {e, c*d, b*d, a*b*c}
	    I' = ideal D'
	    assert (I' == ideal (a*d, b*c*d, a*e, b*e, c*e, d*e) and
		dim D' === 2 and instance(I', Ideal))	    
	Text
	    The irrelevant complex has the empty set as a facet whereas the
	    void complex has no facets.
	Example
	    irrelevant = simplicialComplex {1_S};
	    M = ideal irrelevant
	    void = simplicialComplex monomialIdeal 1_S
	    M' = ideal void	    
	    assert (M == ideal gens S and instance(M, Ideal) and 
		M' == ideal 1_S and instance (M', Ideal))
    	Text
	    This routine is identical to 
	    @TO (monomialIdeal, SimplicialComplex)@ except for the
	    @TO2(Type,"type")@ of the output.
	Example
	    printWidth = 250;
	    code (ideal, SimplicialComplex)	    	
	    code (monomialIdeal, SimplicialComplex)	    
    	Text
	    As the Stanley-Reisner ideal is part the defining data of an
	    abstract simplicial complex, so this method does no computation.
    SeeAlso 
	(facets, SimplicialComplex)
	(monomialIdeal, SimplicialComplex)
	(ring, SimplicialComplex)
///


doc /// 
    Key
        (monomialIdeal, SimplicialComplex)
	"Stanley-Reisner ideal"	
    Headline 
        get the Stanley-Reisner monomial ideal 
    Usage
        monomialIdeal D
    Inputs
	D : SimplicialComplex
    Outputs 
        : MonomialIdeal 
	    that is generated by the monomials representing the minimal
	    nonfaces in {\tt D}
    Description
        Text
	    In this package, an abstract simplicial complex is constructed as
            squarefree monomial ideal in a @TO2((ring, SimplicialComplex),
            "polynomial ring")@.  This method returns the defining monomial
            ideal.
	Text
     	    The @HREF("https://en.wikipedia.org/wiki/5-cell", "4-simplex")@
     	    is a simplicial sphere with $5$ vertices and a minimal nonface
     	    that corresponds to the interior of the sphere.
    	Example
	    S = ZZ[a..e];
	    D = simplicialComplex {b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}
	    I = monomialIdeal D
	    dim D
	    assert (I == monomialIdeal a*b*c*d*e and numgens I === 1 and
		instance(I, MonomialIdeal) and dim D === 3)
    	Text
	    The abstract simplicial complex from Example 1.8 of
            Miller-Sturmfels' {\em Combinatorial Commutative Algebra} consists
            of a triangle (on vertices {\tt a, b, c}), two edges (connecting
            {\tt c} to {\tt d} and {\tt b} to {\tt d}), and an isolated
            vertex (namely {\tt e}).  It has six minimal nonfaces.
    	Example
	    D' = simplicialComplex {e, c*d, b*d, a*b*c}
	    I' = monomialIdeal D'
	    assert (I' == monomialIdeal (a*d, b*c*d, a*e, b*e, c*e, d*e) and
		dim D' === 2 and instance(I', MonomialIdeal))	    
	Text
	    The irrelevant complex has the empty set as a facet whereas the
	    void complex has no facets.
	Example
	    irrelevant = simplicialComplex {1_S};
	    M = monomialIdeal irrelevant
	    void = simplicialComplex monomialIdeal 1_S
	    M' = monomialIdeal void	    
	    assert (M == monomialIdeal gens S and instance(M, MonomialIdeal) 
		and M' == monomialIdeal 1_S and instance (M', MonomialIdeal))
    	Text
	    This routine is identical to @TO (ideal, SimplicialComplex)@
	    except for the @TO2(Type,"type")@ of the output.
	Example
	    printWidth = 250;
	    code (ideal, SimplicialComplex)	    	
	    code (monomialIdeal, SimplicialComplex)	    
    	Text
	    As the Stanley-Reisner ideal is part the defining data of an
	    abstract simplicial complex, so this method does no computation.
    SeeAlso 
	(facets, SimplicialComplex)
	(ideal, SimplicialComplex)
	(ring, SimplicialComplex)
///


doc ///
    Key
        (ring, SimplicialComplex)
    Headline
    	get the polynomial ring of its Stanley-Reisner ideal
    Usage
        ring D
    Inputs
        D : SimplicialComplex
    Outputs
        : PolynomialRing 
    Description
        Text
	    In this package, an abstract simplicial complex is constructed as
            squarefree monomial ideal in a @TO2((ring, SimplicialComplex),
            "polynomial ring")@.  In particular, the vertices of an abstract
            simplicial complex are a subset of variables in the polynomial
            ring.  This method returns the defining polynomial ring.
	Text
     	    The @HREF("https://en.wikipedia.org/wiki/5-cell", "4-simplex")@
     	    is a simplicial sphere with $5$ vertices and a minimal nonface
     	    that corresponds to the interior of the sphere.
    	Example
	    S = ZZ[a..e];
	    D = simplicialComplex {b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}
	    ring D
	    coefficientRing D
	    dim D
	    assert (ring D === S and coefficientRing D === ZZ)
    	Text
	    The abstract simplicial complex from Example 1.8 of
            Miller-Sturmfels' {\em Combinatorial Commutative Algebra} consists
            of a triangle (on vertices {\tt a, b, c}), two edges (connecting
            {\tt c} to {\tt d} and {\tt b} to {\tt d}), and an isolated
            vertex (namely {\tt e}).  It has six minimal nonfaces.
    	Example
	    S' = ZZ/101[a..e];
	    D' = simplicialComplex {e, c*d, b*d, a*b*c}
	    ring D'
	    assert (ring D' === S' and coefficientRing D' === ZZ/101)	    
	Text
	    The irrelevant complex has the empty set as a facet whereas the
	    void complex has no facets.	
	Example
	    irrelevant = simplicialComplex {1_S'};
    	    ring irrelevant
	    void = simplicialComplex monomialIdeal 1_S
    	    ring void	    
	    assert (ring irrelevant === S' and ring void === S)
    	Text
	    As the Stanley-Reisner ideal is part the defining data of an
	    abstract simplicial complex, so this method does no computation.
    Caveat 
	Although an abstract simplicial complex can be represented by a
	Stanley-Reisner ideal in any polynomial ring with a sufficiently large
	number of variables, some operations in this package do depend of the
	choice of the polynomial ring (or its coefficient ring).  For example,
	the @TO2((chainComplex, SimplicialComplex), "chain complex")@ of an
	abstract simplicial complex is typically constructed over the
	coefficient ring of this polynomial ring.
    SeeAlso
        simplicialComplex
        (coefficientRing, SimplicialComplex)
	(monomialIdeal, SimplicialComplex)
///


doc ///
    Key
        (coefficientRing, SimplicialComplex)
    Headline
        get the coefficient ring of the underlying polynomial ring
    Usage
        coefficientRing D
    Inputs
        D : SimplicialComplex
    Outputs
        : Ring
	    that is the coefficient ring of the polynomial ring that contains
	    the defining Stanley-Reisner ideal	    
    Description
        Text
	    In this package, an abstract simplicial complex is constructed as
            squarefree monomial ideal in a @TO2((ring, SimplicialComplex),
            "polynomial ring")@.  This method returns the
            @TO2(coefficientRing, "coefficient ring")@ of this polynomial
            ring.
	Text
     	    The @HREF("https://en.wikipedia.org/wiki/5-cell", "4-simplex")@
     	    is a simplicial sphere with $5$ vertices and a minimal nonface
     	    that corresponds to the interior of the sphere.  We construct this
     	    abstract simplicial complex using three different polynomial
     	    rings.	    
    	Example
	    S = ZZ[a..e];
	    D = simplicialComplex {b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}
	    ring D
	    monomialIdeal D
	    coefficientRing D
	    assert (ring D === S and coefficientRing D === ZZ and 
		numgens ideal D === 1 )	    
    	Example
	    S' = QQ[a..e];
	    D' = simplicialComplex {b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}
	    ring D'
	    monomialIdeal D'
	    coefficientRing D'
	    assert (ring D' === S' and coefficientRing D' === QQ and
		numgens ideal D' === 1)
    	Example
	    S'' = ZZ/101[a..f];
	    D'' = simplicialComplex {b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}
	    ring D''
	    monomialIdeal D''
	    coefficientRing D''
	    assert (ring D'' === S'' and coefficientRing D'' === ZZ/101 and
		numgens ideal D'' === 2)
    	Text
	    As the Stanley-Reisner ideal is part the defining data of an
	    abstract simplicial complex, so this method does no computation.	
    	Text
	    Although an abstract simplicial complex can be represented by a
	    Stanley-Reisner ideal in any polynomial ring with a sufficiently
	    large number of variables, some operations in this package do
	    depend of the choice of the polynomial ring (or its coefficient ring).
	    For example, the @TO2((chainComplex, SimplicialComplex), "chain
	    complex")@ of an abstract simplicial complex is typically
	    constructed over the coefficient ring of this polynomial ring.
	Example
    	    C = chainComplex D
	    C' = chainComplex D'
	    C'' = chainComplex D''
	    assert (C' == C ** QQ and C'' == C ** (ZZ/101))
    SeeAlso
        (ring, SimplicialComplex)
        (chainComplex, SimplicialComplex)
///

 
doc ///
    Key
        (dim, SimplicialComplex)
    Headline
        find the dimension of an abstract simplicial complex
    Usage
        dim D
    Inputs
        D : SimplicialComplex
    Outputs
        : ZZ
	    one less than the maximum number of vertices in a face
    Description
    	Text
	    A face $F$ in an abstract simplicial complex $D$ of cardinality
	    $|F| = i + 1$ has {\bf dimension} $i$.  The dimension of $D$ is
	    the maximum of the dimensions of its faces or it is 
	    {\tt - infinity} if $D$ is the void complex which has no faces.
	Text
     	    The @HREF("https://en.wikipedia.org/wiki/5-cell", "4-simplex")@
     	    is a simplicial $3$-sphere with $5$ vertices and a minimal nonface
     	    that corresponds to the interior of the sphere.
    	Example
	    S = ZZ[a..e];
	    D = simplicialComplex {b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}
	    monomialIdeal D
	    dim D
	    assert (dim D === 3 and numgens ideal D === 1 and isPure D)
    	Example
	    S' = ZZ/101[a..f];
	    D' = simplicialComplex {b*c*d*e, a*c*d*e, a*b*d*e, a*b*c*e, a*b*c*d}
	    monomialIdeal D'
	    dim D'
	    assert (dim D' === 3 and numgens ideal D' === 2 and isPure D)	    
    	Text
	    The abstract simplicial complex from Example 1.8 of
            Miller-Sturmfels' {\em Combinatorial Commutative Algebra} consists
            of a triangle (on vertices {\tt a, b, c}), two edges (connecting
            {\tt c} to {\tt d} and {\tt b} to {\tt d}), and an isolated
            vertex (namely {\tt e}).  It has six minimal nonfaces.
    	Example
	    S'' = QQ[a..e];
	    D'' = simplicialComplex {e, c*d, b*d, a*b*c}
	    monomialIdeal D''
	    dim D''
	    assert (dim D'' === 2 and not isPure D'')	    
	Text
	    The irrelevant complex has the empty set as a facet whereas the
	    void complex has no facets.  The irrelevant complex has dimension
	    $-1$ while the void complex has dimension {\tt - infinity}.
	Example
	    irrelevant = simplicialComplex {1_S'};
    	    dim irrelevant
	    void = simplicialComplex monomialIdeal 1_S
    	    dim void	    
	    assert (dim irrelevant === -1 and dim void === -infinity)
	Text
	    To avoid repeating a computation, the package caches the result in
	    the @TO CacheTable@ of the abstract simplicial complex.
    SeeAlso
    	(facets, SimplicialComplex)
        simplicialComplex
	(isPure, SimplicialComplex)
///


document { 
     Key => {simplicialComplex,
	 (simplicialComplex,MonomialIdeal),
	  (simplicialComplex,List)},
     Headline => "create a simplicial complex",
     Usage => "simplicialComplex I\nsimplicialComplex L",
     Inputs => {
	  "I" => MonomialIdeal => "the ideal of minimal nonfaces (Stanley-Reisner ideal)",
	  "L" => List => "a list of monomials representing the facets"
          },
     Outputs => {
	  SimplicialComplex => {"the simplicial complex determined by the nonfaces ", TT "I", " 
	  or generated by the given faces ", TT "L"}
          },
     "A simplicial complex on a set of vertices 
     is a collection of subsets 
     ", TT "D", " of
     these vertices, such that if ", TT "F", " is in ", TT "D", ", 
     then every subset of ", TT "F", " is also in ", TT "D", ".
     In Macaulay2, the vertices are variables in a polynomial ring,
     and each subset is represented as a product of the
     corresponding variables.",
     PARA{},
     "A simplicial complex is determined either by its nonfaces or by its faces.
     The monomials corresponding to the nonfaces are a basis of an ideal,
     called the Stanley-Reisner ideal, and
     it suffices to specify the minimal nonfaces, which generate the ideal.
     The monomials corresponding to the faces do not form the basis of an ideal,
     but it suffices to specify the maximal faces, which are called 
     ", EM "facets", ".  The function ", TO "simplicialComplex", " accepts either
     the ideal of nonfaces or the list of facets as input.",
     PARA{},
     "In our first example we construct the octahedron by specfying its
     ideal of nonfaces.",
     EXAMPLE {
	  "R = ZZ[a..f];",
	  "I = monomialIdeal(a*f, b*d, c*e);",
	  "Octahedron = simplicialComplex I"
          },
     "Note that ", ofClass SimplicialComplex, " is displayed by showing its
     facets.  We see that there are eight facets to the octahedron.  Alternatively,
     we could have defined the octahedron by this list of facets.",
     EXAMPLE {
	  "L = {d*e*f, b*e*f, c*d*f, b*c*f, 
	       a*d*e, a*b*e, a*c*d, a*b*c}",
	  "Octahedron' = simplicialComplex L",
	  "Octahedron == Octahedron'",
	  "fVector Octahedron"
	  },
     "There are two \"trivial\" simplicial complexes: the void 
     complex and the irrelevant complex.  The void complex
     has no faces.  This complex cannot be constructed from
     its facets, since it has none.",
     EXAMPLE {
	  "void = simplicialComplex monomialIdeal 1_R",
	  "fVector void",
	  "dim void"
	  },
     "The irrelevant complex, which should be distinguished 
     from the void complex, has a unique face of dimension -1, 
     the empty set.",
     EXAMPLE {
	  "irrelevant = simplicialComplex monomialIdeal gens R",
	  "fVector irrelevant",
	  "dim irrelevant",
	  "irrelevant' = simplicialComplex {1_R}",
	  "irrelevant' == irrelevant"
	  },
     "As in Miller-Sturmfels, Combinatorial Commutative
     Algebra, we would avoid making such a big deal about 
     the difference between these complexes if it did not
     come up so much.  Many formulas for betti numbers, 
     dimensions of local cohomology, etc., depend on this
     distinction.",
     Caveat => UL {
	   {"The ring of ", TT "I", " or ", TT "L", 
		" must be a polynomial ring."},
	   {"The ", TO2(coefficientRing, "coefficient ring"),
	   " matters: for instance,
	   it is used when 
	   computing the corresponding chain complex."},
	   "This construction routine does some computation, as it
	   computes both the facets and the ideal of non-faces."
	   },
     SeeAlso => {SimplicialComplexes, fVector}
     }
 
 
------------------------------------------------------------------------------
-- basic properties and invariants
------------------------------------------------------------------------------
doc ///
    Key 
        "finding attributes and properties"
    Headline
        information about accessing features of an abstract simplicial complex
    Description
        Text
            Having made a @TO SimplicialComplex@, one can access its basic
            invariants or test for some elementary properties by using the
            following methods:
    	Text
	    @SUBSECTION "Determining attributes and properties of simplicial complexes"@
	Text
            @UL {
        	TO (facets, SimplicialComplex),
        	TO (ideal, SimplicialComplex),		
        	TO (monomialIdeal, SimplicialComplex),
        	TO (dim, SimplicialComplex)
	    }@
    SeeAlso
        "making an abstract simplicial complex"
///
 
 

document { 
     Key => boundary,
     Headline => "boundary operator",
     SeeAlso => {SimplicialComplexes}
     }
 
 
document { 
     Key => (boundary,ZZ,SimplicialComplex),
     Headline => "the boundary map from i-faces to (i-1)-faces",
     Usage => "M = boundary(i,D)",
     Inputs => {
	  "i",
	  "D"
          },
     Outputs => {
	  "M" => Matrix => {"the boundary map from ", TT "i", 
	       "-faces to ", TT "(i-1)", "-faces of ", TT "D"}
          },
     "The columns of the matrix ", TT "M", " are indexed by the ", TT "i", "-faces of
     ", TT "D", ", and the rows are indexed by the ", TT "(i-1)", "-faces, in the order
     given by ", TO faces, ".  ", TT "M", " is defined over the ", 
     TO2((coefficientRing,SimplicialComplex),"coefficient ring"), " of ", TT "D", ".",
     "The boundary maps for the standard 3-simplex, defined over ", TT "ZZ", ".",
     EXAMPLE {
	  "R = ZZ[a..d];",
	  "D = simplicialComplex {a*b*c*d}",
	  "boundary(0,D)",
	  "faces(0,D)",
          "boundary(1,D)",
	  "faces(1,D)",
	  "boundary(2,D)",
	  "faces(2,D)",
	  "boundary(3,D)",
	  "faces(3,D)",
	  "boundary(4,D)"
	  },
     "The boundary maps depend on the ",
     TO2((coefficientRing,SimplicialComplex),"coefficient ring"), 
     " as the following examples illustrate.",
     EXAMPLE {
	  "R = QQ[a..f];",
	  "D = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f);",
	  "boundary(1,D)",
	  "R' = ZZ/2[a..f];",
	  "D' = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f);",
	  "boundary(1,D')"
	  },
     SeeAlso => {SimplicialComplexes, (chainComplex,SimplicialComplex), faces}
     }
 
 
document { 
     Key => (boundary,SimplicialComplex),
     Headline => "the boundary simplicial complex of D",
     Usage => "boundary D",
     Inputs => {
	  "D"
          },
     Outputs => {
	  SimplicialComplex => {"the boundary simplicial complex, 
	   i.e. the subcomplex of ", TT "D", 
	   " consisting of all nonmaximal faces of ", TT "D"},
          },
     "The boundary of the standard 3-simplex is the 2-sphere.",
     EXAMPLE {
          "R = ZZ[a..d];",
          "D = simplicialComplex{a*b*c*d}",
	  "sphere = boundary D",
	  "fVector sphere",
	  "fVector D"  
	  },
     "Facets may be of different dimensions.",
     EXAMPLE {
          "R = ZZ[a..g];",
          "D = simplicialComplex{a*b*c,a*d,d*f,g*c,e,f*g}",
	  "E = boundary D",
	  "fVector D",
	  "fVector E"
	  },
     SeeAlso => {SimplicialComplexes, fVector, isPure, facets}
     }


document { 
     Key => {buchbergerComplex, (buchbergerComplex,List,Ring), (buchbergerComplex,MonomialIdeal)},
     Headline => "Buchberger complex of a monomial ideal",
     Usage => "buchbergerComplex(L,R)\nbuchbergerComplex I",
     -- Inputs => {
     --      },
     -- Outputs => {
     --      },
     -- Consequences => {
     --      },     
     -- "description",
     -- EXAMPLE {
     --      },
     -- Caveat => {},
 
     SeeAlso => {SimplicialComplexes}
     }


document { 
     Key => {lyubeznikComplex, (lyubeznikComplex,List,Ring), (lyubeznikComplex,MonomialIdeal)},
     Headline => "Simplicial complex supporting the Lyubeznik resolution of a  monomial ideal",
     Usage => "lyubeznikComplex(L,R)\nlyubeznikComplex I",
     -- Inputs => {
     --      },
     -- Outputs => {
     --      },
     -- Consequences => {
     --      },     
     -- "description",
     -- EXAMPLE {
     --      },
     -- Caveat => {},

     SeeAlso => {SimplicialComplexes}
     }

document { 
     Key => {superficialComplex, (superficialComplex,List,Ring), (superficialComplex,MonomialIdeal)},
     Headline => "Simplicial complex supporting a superficial resolution of a monomial ideal",
     Usage => "superficialComplex(L,R)\nsuperficialComplex I",
     -- Inputs => {
     --      },
     -- Outputs => {
     --      },
     -- Consequences => {
     --      },     
     -- "description",
     -- EXAMPLE {
     --      },
     -- Caveat => {},

     SeeAlso => {SimplicialComplexes}
     }




document { 
     Key => {(isPure,SimplicialComplex)},
     Headline => "whether the facets are equidimensional",
     Usage => "isPure D",
     Inputs => {
	  "D" => SimplicialComplex
          },
     Outputs => {
	  Boolean => {TO true, " if the facets of ", TT "D", " all have the same dimension, 
	       and ", TO false, " otherwise"}
          },
     EXAMPLE {
          "R = ZZ[a..f];",
	  "D = simplicialComplex {a*b*c, a*b*d, d*e*f} ",
	  "isPure D"
	  },
     EXAMPLE {
	  "E = simplicialComplex {a*b*c, b*d, d*e*f} ",
	  "isPure E"
          },
     SeeAlso => {SimplicialComplexes, (dim,SimplicialComplex),facets}
     }
 

document { 
     Key => {label, (label,SimplicialComplex,List)},
     Headline => "labels with monomials the faces of simplicial complex",
     -- Usage => "",
     -- Inputs => {
     --      },
     -- Outputs => {
     --      },
     -- Consequences => {
     --      },     
     -- "description",
     -- EXAMPLE {
     --      },
     -- Caveat => {},
     -- SeeAlso => {}
     }
document { 
     Key => {link,(link,SimplicialComplex,RingElement)},
     Headline => "link of a face in a simplicial complex",
     Usage => "link(D,f)",
     Inputs => {
	  "D" => SimplicialComplex,
	  "f" => RingElement => {"a monomial representing a face of the simplicial complex ", TT "D"}
          },
     Outputs => {
	  SimplicialComplex => {"the link of ", TT "f", " in ", TT "D"}
          },
     TEX "The link of a face $f$ in $D$ is the simplicial complex whose faces 
     are the subsets $g$ whose intersection
     with $f$ is empty, where $f \\cup g$ is a face of $D$.",
     EXAMPLE {
	  "R = QQ[x0,x1,x2,x3,x4,x5,x6];",
	  "D = simplicialComplex {x0*x1*x3, x1*x3*x4, x1*x2*x4, x2*x4*x5,
	       x2*x3*x5, x3*x5*x6, x3*x4*x6, x0*x4*x6,
	       x0*x4*x5, x0*x1*x5, x1*x5*x6, x1*x2*x6,
	       x0*x2*x6, x0*x2*x3}",
	  "link(D,x0)",
	  "link(D,x0*x2)"
	  },
     SeeAlso => {SimplicialComplexes
	  }
     }
document { 
     Key => (dual,SimplicialComplex),
     Headline => "the Alexander dual of a simplicial complex",
     Usage => "dual D",
     Inputs => {
	  "D"
          },
     Outputs => {
	  SimplicialComplex => {"the Alexander dual of ", TT "D"}
          },
     "The Alexander dual of ", TT "D", " is the simplicial complex
     whose faces are the complements of the nonfaces of ", TT "D", ".
     The Alexander dual of a square is the disjoint union of
     two edges.",
     EXAMPLE {
	  "R = ZZ[a..d];",
	  "D = simplicialComplex {a*b,b*c,c*d,d*a}",
          "dual D"
	  },
     PARA{},
     "The Alexander dual is homotopy equivalent to the complement of ", TT "D", " in the sphere generated
     by all of the variables in the ", TO2((ring,SimplicialComplex),"ring"),
     " of ", TT "D", ".  In particular, it depends on the number of variables.",
     EXAMPLE {
	  "R = ZZ[a..e]",
	  "E = simplicialComplex {a*b,b*c,c*d,d*a}",
          "dual E"
          },
     "The projective dimension of the face ring of D equals the
     regularity of the face ideal of the Alexander dual of D
     see e.g., Corollary 5.59 of Miller-Sturmfels, Combinatorial
     Commutative Algebra.",
     EXAMPLE {
	  "R = QQ[a..f];",
	  "D = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f)",
	  "A = dual D",
	  "pdim (R^1/(ideal D))",
	  "regularity ideal A"
	  },
     PARA{},
     "Alexander duality interchanges extremal betti numbers of the face ideals.
     Following example 3.2 in Bayer-Charalambous-Popescu, ", EM "Extremal betti
     numbers and applications to monomial ideals", ", we have ",
     EXAMPLE {
	  "R = QQ[x0,x1,x2,x3,x4,x5,x6];",
	  "D = simplicialComplex {x0*x1*x3, x1*x3*x4, x1*x2*x4, x2*x4*x5,
	       x2*x3*x5, x3*x5*x6, x3*x4*x6, x0*x4*x6,
	       x0*x4*x5, x0*x1*x5, x1*x5*x6, x1*x2*x6,
	       x0*x2*x6, x0*x2*x3}",
	  "I = ideal D",
	  "J = ideal dual D",
	  "betti res I",
	  "betti res J"
	  },
     SeeAlso => {SimplicialComplexes, (dual,MonomialIdeal)}
     }

///
-- Greg and Mike were working on this when Greg had to go home
-- 7/13/05  Good example though!
     "Hochster gives a formula relating the homology of the Alexander dual 
     to the betti numbers of the Stanley-Reisner ideal, see e.g., 
     Corollary 1.40 in
     Miller-Sturmfels, Combinatorial Commutative Algebra. ",
     EXAMPLE {
	  --R = QQ[a..f];
	  R = QQ[a..f, Degrees => {
                          {1, 1, 0, 0, 0, 0, 0}, 
                          {1, 0, 1, 0, 0, 0, 0}, 
                          {1, 0, 0, 1, 0, 0, 0}, 
			  {1, 0, 0, 0, 1, 0, 0}, 
			  {1, 0, 0, 0, 0, 1, 0}, 
			  {1, 0, 0, 0, 0, 0, 1}}]
	  oct = simplicialComplex monomialIdeal(a*b,c*d,e*f)
	  cube = dual oct
	  lk = (D,m) -> simplicialComplex monomialIdeal(ideal support m + ((ideal D):m));
	  F = link(oct,a)
	  rank HH_1(F)
	  C = res ideal cube
	  tally degrees C_3
	  checkHochster = (D,face) -> (
	       R := ring D;
	       face' := (product gens R) // face;
	       D' := dual D;
	       h := apply(0..dim D', i -> (
     	           rank HH_(i-1)(link(D',face'))));
	       C := res ideal D;
	       b := apply(0..dim D', i -> (
			 d := tally degrees C_(i+1);
			 if d#?(degree face) then d#(degree face) else 0));
	       (b,h))
          checkHochster(cube,b*d*e*f)
	  checkHochster(oct,a*c)
	  checkHochster(oct,a*b)
	  checkHochster(oct,c*d*e*f)
	  checkHochster(cube,a*b*c*d*e)
	  },
///

document { 
     Key => {(faces,ZZ,SimplicialComplex)},
     Headline => "the i-faces of a simplicial complex ",
     Usage => "faces(i,D)",
     Inputs => {
	  "i" => ZZ => "the dimension of the faces",
	  "D" => SimplicialComplex
          },
     Outputs => {
	  Matrix => {"with one row, whose entries are squarefree
	       monomials representing the faces of dimension ", 
	       TT "i", " of ", TT "D"}
          },
     "In Macaulay2, every ", TO2(SimplicialComplex, "simplicial complex"),
     " is equipped with a polynomial ring, and the matrix of i-faces
     is defined over this ring.",
     PARA {
     	  "This triangulation of the real projective plane has 6
     	  vertices, 15 edges and 10 triangles."
	  },
     EXAMPLE {
	  "R = ZZ[a..f]",
	  "D = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,
	                                      b*c*d,b*d*e,b*e*f,c*d*f,c*e*f)",
          "faces(-1,D)",
	  "faces(0,D)",
	  "faces(1,D)",
	  "faces(2,D)",
	  "fVector D"
          },
     PARA{},
     "To avoid repeated computation, 
     the matrix of ", TT "i", "-faces is cached at ", 
     TT "D.cache.faces#i", ".
     This function will use this value if it has already been 
     computed.",
     SeeAlso => {SimplicialComplexes,
	  facets,
	  boundary,
	  fVector
	  }
     }




-------------------------------------------------------------
-------------------------------------------------------------
-- 20/07/2018 Lorenzo: new/modified documentation

document {
     Key => {(skeleton,ZZ,SimplicialComplex)},
     Headline => "the n-skeleton of the simplicial complex D",
     Usage => "skeleton(n,D)",
     Inputs => {
      "i" => ZZ,
      "D" => SimplicialComplex
          },
     Outputs => {
      SimplicialComplex => {"the ", TT "n","-skeleton of a simplicial complex,
       i.e. the subcomplex of all subfaces of dimension at most ", TT "n"},
          },
     "The 2-skeleton of the 5-simplex.",
     EXAMPLE {
          "R = ZZ[a..f];",
          "D = simplicialComplex{a*b*c*d*e*f}",
      "skel = skeleton(2, D)",
      "fVector D",
      "fVector skel"
      },
     SeeAlso => {SimplicialComplexes, fVector, faces}
     }

document {
     Key => {(fVector,SimplicialComplex)},
     Headline => "the f-vector of a simplicial complex",
     Usage => "f = fVector D",
     Inputs => {
      "D" => SimplicialComplex
          },
     Outputs => {
      "f" => {"such that ", TT "f#i",
      " is the number of faces in ", TT "D",
      " of dimension ", TT "i", " for ", TT "-1 <= i <= dim D", " or of squarefree degree ", TT "i."}
          },
     "The pentagonal bipyramid has 7 vertices, 15 edges
     and 10 triangles.",
     EXAMPLE {
      "R = ZZ[a..g];",
      "biPyramid = simplicialComplex monomialIdeal(
      a*g, b*d, b*e, c*e, c*f, d*f)",
      "f = fVector biPyramid",
      "f#0",
      "f#1",
      "f#2"
          },
     "Every simplicial complex other than the void
     complex has a unique face of dimension -1.",
     EXAMPLE {
      "void = simplicialComplex monomialIdeal 1_R",
      "fVector void"
      },
     "For a larger examp;le we consider the polarization
     of an artinian monomial ideal from section 3.2 in
     Miller-Sturmfels, Combinatorial Commutative Algebra.",
     EXAMPLE {
      "S = ZZ[x_1..x_4, y_1..y_4, z_1..z_4];",
      "I = monomialIdeal(x_1*x_2*x_3*x_4,
           y_1*y_2*y_3*y_4,
           z_1*z_2*z_3*z_4,
           x_1*x_2*x_3*y_1*y_2*z_1,
           x_1*y_1*y_2*y_3*z_1*z_2,
           x_1*x_2*y_1*z_1*z_2*z_3);",
          "D = simplicialComplex I;",
      "fVector D"
      },
      "The boundary of the 3-dimensional cross-polytope is
      3-colorable. If we define this simplicial complex over
      a ", TT "Z^3", "-graded ring we can ask for its flag
      f-vector.",
      EXAMPLE {
      "grading = {{1,0,0},{1,0,0},{0,1,0},{0,1,0},{0,0,1},{0,0,1}};",
      "S = ZZ[x_1..x_6, Degrees => grading];",
      "I = monomialIdeal(x_1*x_2,x_3*x_4,x_5*x_6);",
      "fVector simplicialComplex I",
      },
      
     Caveat => {
     "The option ", TT "Flag", " checks if the multigrading corresponds to a properly d-coloring of "
     , TT "D", ", where d is the dimension of ", TT "D", " plus one. If it is not the case the output
     is an empty HashTable."
     },
     PARA{},
     "The f-vector is computed using the Hilbert series
     of the Stanley-Reisner ideal.  For example, see
     Hosten and Smith's
     chapter Monomial Ideals, in Computations in
     Algebraic Geometry with Macaulay2, Springer 2001.",
     SeeAlso => {SimplicialComplexes,
      faces}
     }
--fVector(simplicialComplex I, Flag => true)

document {
     Key => {algebraicShifting,(algebraicShifting,SimplicialComplex),[algebraicShifting,Multigrading]},
     Headline => "the algebraic shifting of a simplicial complex",
     Usage => "A = algebraicShifting D",
     Inputs => {
     "D" => SimplicialComplex,
     Multigrading => Boolean => "If true it returns the colored algebraic shifting w.r.t. the multigrading of the underlying ring."
          },
     Outputs => {
     "A" => {"The algebraic shifting of the simplicial complex ", TT "D", ". If ", TT "Multigrading => true", " then it returns the so called colored shifted complex."}
          },
     "The boundary of the stacked 4-polytope on 6 vertices. Algebraic shifting preserves the f-vector.",
     EXAMPLE {
      "R=QQ[x_1..x_6];",
      "I=monomialIdeal(x_2*x_3*x_4*x_5,x_1*x_6);",
      "stacked = simplicialComplex(I)",
      "shifted = algebraicShifting(stacked)",
      "fVector stacked",
      "fVector shifted"
          },
     "An empty triangle is a shifted complex.",
     EXAMPLE {
     "R=QQ[a,b,c];",
     "triangle = simplicialComplex{a*b,b*c,a*c};",
     "algebraicShifting(triangle) == triangle "
     },
     "The multigraded algebraic shifting does not preserve the Betti numbers.",
     EXAMPLE {
      "grading = {{1,0,0},{1,0,0},{1,0,0},{0,1,0},{0,0,1}};",
      "R=QQ[x_{1,1},x_{1,2},x_{1,3},x_{2,1},x_{3,1}, Degrees=>grading];",
      "delta = simplicialComplex({x_{1,3}*x_{2,1}*x_{3,1},x_{1,1}*x_{2,1},x_{1,2}*x_{3,1}})",
      "shifted = algebraicShifting(delta, Multigrading => true)",
      "prune (homology(delta))_1",
      "prune (homology(shifted))_1"
     },
     "References:",
     PARA {},
     "G. Kalai, Algebraic Shifting, Computational Commutative Algebra and Combinatorics, 2001;",
      PARA {},
     "S. Murai, Betti numbers of strongly color-stable ideals and squarefree strongly color-stable ideals, Journal of Algebraic Combinatorics."
     }

--These are documented in the above node.
undocumented { "Multigrading" }

document {
     Key => {star,(star,SimplicialComplex,RingElement)},
     Headline => "star of a face in a simplicial complex",
     Usage => "star(D,f)",
     Inputs => {
      "D" => SimplicialComplex,
      "f" => RingElement => {"a monomial representing a face of the simplicial complex ", TT "D"}
          },
     Outputs => {
      SimplicialComplex => {"the star of ", TT "f", " in ", TT "D"}
          },
     TEX "The star of a face $f$ in $D$ is the simplicial complex whose faces
     are the subsets $g$ with $f \\cup g$ is a face of $D$.",
     PARA {},
     " The bow-tie complex.",
     EXAMPLE {
      "R = QQ[x_1..x_5];",
      "bowtie = simplicialComplex {x_1*x_2*x_3,x_3*x_4*x_5}",
      "star(bowtie,x_3)",
      "star(bowtie,x_1*x_2)"
      },
     PARA {},
     " The 3-simplex and a copy of its boundary glued along a triangle.",
     EXAMPLE {
      "R = QQ[a..e];",
      "D = simplicialComplex {a*b*c*d, b*c*e, b*d*e, c*d*e}",
      "star(D,b*c*d)",
      "star(D,b)"
      },
     SeeAlso => {SimplicialComplexes, link
      }
     }

document {
     Key => {joinSimplicial,(joinSimplicial,SimplicialComplex,SimplicialComplex)},
     Headline => "the join of two simplicial complexes",
     Usage => "joinSimplicial(D,E)",
     Inputs => {
      "D" => SimplicialComplex,
      "E" => SimplicialComplex
          },
     Outputs => {
      SimplicialComplex => {"the join of ", TT "D", " and ", TT "E"}
          },
     TEX "The join of two simplicial complexes $D$ and $E$ is the simplicial complex whose faces
     are the union of faces of $D$ and $E$. If $D$ is the simplicial complex consisting of a
     single vertex then the join is the cone over $E$. If $D$ consists of two isolated vertices
     then the join is the suspension of $E$.",
     PARA {},
     " The cone over a bow-tie complex.",
     EXAMPLE {
      "R = QQ[x_1..x_5];",
      "bowtie = simplicialComplex {x_1*x_2*x_3, x_3*x_4*x_5};",
      "S = QQ[v];",
      "singleton = simplicialComplex {v};",
      "singleton * bowtie"
      },
     PARA {},
     " The octahedron is the suspension of a square.",
     EXAMPLE {
      "R = QQ[a..d];",
      "square = simplicialComplex {a*b, b*c, c*d, a*d};",
      "S = QQ[p,q];",
      "poles = simplicialComplex {p, q};",
      "octahedron = joinSimplicial(poles,square)"
      },
      PARA {},
      " The join of an exagon and a pentagon.",
      EXAMPLE {
      "R = ZZ[x_1..x_6];",
      "exagon = simplicialComplex {x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_5,x_5*x_6,x_1*x_6};",
      "S = ZZ[y_1..y_5];",
      "pentagon = simplicialComplex {y_1*y_2,y_2*y_3,y_3*y_4,y_4*y_5,y_1*y_5};",
      "sphere = joinSimplicial(exagon,pentagon)",
      "fVector(sphere)"
      },
      Caveat => {
      "The two simplicial complexes have to be defined over different polynomial rings."
      },
      SeeAlso => {SimplicialComplexes, (symbol *,SimplicialComplex,SimplicialComplex)
      }
     }

document {
     Key => (symbol *,SimplicialComplex,SimplicialComplex),
     Headline => "the join of two simplicial complexes",
     Usage => "  J = D * E",
     Inputs => {
      "D" => SimplicialComplex,
      "E" => SimplicialComplex
      },
     Outputs => {
      "J" => SimplicialComplex
      },

     PARA{}, "Computes join of ",TT "D"," and ",TT "E",".",

     PARA{}, "See also ",TO joinSimplicial,".",

     }



doc ///
  Key
    Face
  Headline
   The class of faces of simplicial complexes.
  Description
   Text
        The class of faces of simplicial complexes on the variables of a polynomial ring.
        The faces are @TO MutableHashTable@s F with two @TO keys@
        
        F.vertices is a @TO List@ of vertices in the @TO PolynomialRing@ F.ring

   Example
     R=QQ[x_0..x_4];
     F=face {x_0,x_2}
     I=monomialIdeal(x_0*x_1,x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_0);
     D=simplicialComplex I
     fc=faces(1,D)
     -- select(fc,j->j==F)
  SeeAlso
     SimplicialComplex
     faces
     facets
///


doc ///
  Key
    (symbol ==,Face,Face)
  Headline
   Compare two faces.
  Usage
    F==G
  Inputs
    F:Face
    G:Face
  Outputs
    :Boolean
  Description
   Text
        Checks whether F and G are equal.

   Example
     K=QQ;
     R=K[x_0..x_4];
     F=face {x_0,x_1}
     G1=face {x_1,x_0}
     G2=face {x_1,x_2}
     F==G1
     F==G2
  SeeAlso
     Face
     face
///


doc ///
  Key
    face
    (face,List)
    (face,List,PolynomialRing)
    (face,RingElement)
  Headline
    Generate a face.
  Usage
    face(L)
    face(L,R)
    face(m)
  Inputs
    L:List
    R:PolynomialRing
    m:RingElement
        a monomial
  Outputs
    :Face
  Description
   Text
        Generates a face out of a list L or a squarefree monomial.
        If L is not empty or a monomial the argument R is not required.

   Example
     K=QQ;
     R=K[x_0..x_4];
     F=face {x_0,x_1}
  SeeAlso
     SimplicialComplex
     faces
     facets
///

doc ///
  Key
    (dim,Face)
  Headline
    The dimension of a face.
  Usage
    dimension(F)
  Inputs
    F:Face
  Outputs
    :ZZ
      bigger or equal to -1
  Description
   Text
        Returns the dimension of a @TO Face@, i.e., the number of @TO vertices@ F minus 1.

   Example
     K=QQ;
     R=K[x_0..x_4];
     I=monomialIdeal(x_0*x_1,x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_0);
     D=simplicialComplex I
     fc = faces(D)
     -- apply(-1..1, j->apply(fc#j,dim))
  SeeAlso
     face
     facets
     faces
///

doc ///
  Key
    (vertices,Face)
  Headline
    The vertices of a face of a simplicial complex.
  Usage
    vertices(F)
  Inputs
    F:Face
  Outputs
    :List
  Description
   Text
        Returns a @TO List@ with the vertices of a @TO Face@ of a simplicial complex.

   Example
     R = QQ[x_0..x_4];
     I = monomialIdeal(x_0*x_1,x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_0);
     D = simplicialComplex I
     fc = facets(D)
     -- vertices fc#1
  SeeAlso
     face
     facets
     faces
///

doc ///
  Key
    isSubface
    (isSubface,Face,Face)
  Headline
    Test whether a face is a subface of another face.
  Usage
    isSubface(F,G)
  Inputs
    F:Face
    G:Face
  Outputs
    :Boolean
  Description
   Text
        Test whether F is a subface of G.

   Example
     K=QQ;
     R=K[x_0..x_4];
     G=face {x_0,x_1,x_2}
     F1=face {x_0,x_2}
     F2=face {x_0,x_3}
     isSubface(F1,G)
     isSubface(F2,G)
///

doc ///
  Key
    (substitute,Face,PolynomialRing)
  Headline
    Substitute a face to a different ring.
  Usage
    substituteFace(F,R)
  Inputs
    F:Face
    R:PolynomialRing
  Outputs
    :Face
  Description
   Text
        Substitute a face to a different ring.

   Example
     K=QQ;
     R=K[x_0..x_4];
     F=face {x_0,x_1,x_2}
     S=R**K[y]
     substitute(F,S)
///

doc ///
  Key
    (ring,Face)
  Headline
    Ring of a face.
  Usage
    ring(F)
  Inputs
    F:Face
  Outputs
    :Ring
  Description
   Text
        Ring of a face.

   Example
     K=QQ;
     R=K[x_0..x_4];
     F=face {x_0,x_1,x_2}
     ring F
///


doc ///
  Key
    (substitute,SimplicialComplex,PolynomialRing)
  Headline
    Substitute a simplicial complex to a different ring.
  Usage
    substitute(C,R)
  Inputs
    C:SimplicialComplex
    R:PolynomialRing
  Outputs
    :SimplicialComplex
  Description
   Text
        Substitute a simplicial complex to a different ring. R should contain the variables of the @TO ring@ of C.

   Example
     K=QQ;
     R=K[x_0..x_4];
     I=monomialIdeal(x_0*x_1,x_1*x_2,x_2*x_3,x_3*x_4,x_4*x_0);
     C=simplicialComplex I
     S=R**K[y]
     C1=substitute(C,S)
     ring C1
  SeeAlso
     (substitute,Face,PolynomialRing)
///

doc ///
  Key
    isFaceOf
    (isFaceOf,Face,SimplicialComplex)
  Headline
    Substitute a face to a different ring.
  Usage
    substitute(F,R)
  Inputs
    F:Face
    R:PolynomialRing
  Outputs
    :Face
  Description
   Text
        Substitute a face to a different ring.

   Example
     R = QQ[x_1..x_5];
     C = simplicialComplex monomialIdeal (x_1*x_2,x_3*x_4*x_5)
     F1 = face {x_1,x_2}
     F2 = face {x_1,x_3}
     -- isFaceOf(F1,C)
     -- isFaceOf(F2,C)
///

doc ///
  Key
    (net,Face)
  Headline
    Printing a face.
  Usage
    net(F)
  Inputs
    F:Face
  Outputs
    :Net
  Description
   Text
        Prints a face. The vertices are printed without any brackets and with one space between them. Also prints the polynomial ring which contains the vertices.

   Example
     K=QQ;
     R=K[x_0..x_4];
     face {x_0,x_1}
///

///
  Key
    useFaceClass
    [faces,useFaceClass]
    [facets,useFaceClass]
  Headline
    Option to return faces in the class Face
  Description
   Text
    @TO Boolean@ @TO Option@ to return in the methods @TO faces@ and @TO facets@ a @TO List@ of @TO Face@s instead of a @TO Matrix@.
///

doc ///
  Key
    (faces,SimplicialComplex)
  Headline
    Compute all faces of a simplicial complex.
  Usage
    faces(C)
  Inputs
    C : SimplicialComplex
  Outputs
    : HashTable
  Description
   Text
        Return a list of lists of the faces of a simplicial complex.

   Example
    R = QQ[x_1..x_5];
    C = simplicialComplex monomialIdeal (x_1*x_2,x_3*x_4*x_5)
    fc = faces(C)
    fc#2
 ///


-------------------------------------------------------------------
-- some previously missing documentation


doc ///
  Key
    (symbol ==,SimplicialComplex,SimplicialComplex)
  Headline
   Compare two simplicial complexes.
  Usage
    C1==C2
  Inputs
    C1:SimplicialComplex
    C2:SimplicialComplex
  Outputs
    :Boolean
  Description
   Text
        Checks whether C1 and C2 are equal.

   Example
    K=QQ;
    R=K[x_1..x_3];
    C1=simplicialComplex monomialIdeal (x_1*x_2*x_3)
    C2=simplicialComplex {face {x_1,x_2},face {x_2,x_3},face {x_3,x_1}}
    C1==C2
///


doc ///
  Key    
    (chainComplex,SimplicialComplex)
    simplicialChainComplex
    (simplicialChainComplex,List,SimplicialComplex)
  Headline
    The chain complex of boundary maps.
  Usage
    chainComplex C
  Inputs
    C:SimplicialComplex
  Outputs
    :ChainComplex
  Description
   Text
     The @TO ChainComplex@ of @TO boundary@ maps from i-faces to (i-1)-faces.

   Example
    R = QQ[a..f];
    D = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f);
    R' = ZZ/2[a..f];
    D' = simplicialComplex monomialIdeal(a*b*c,a*b*f,a*c*e,a*d*e,a*d*f,b*c*d,b*d*e,b*e*f,c*d*f,c*e*f);
    c = chainComplex D
    c' = chainComplex D'
    c.dd_1
    c'.dd_1
  SeeAlso
   boundary
///


doc ///
  Key    
    (homology,ZZ,SimplicialComplex)
  Headline
    Compute the homology of a simplicial complex.
  Usage
    homology(j,C)
  Inputs
    j:ZZ
    C:SimplicialComplex
  Outputs
    :Module
  Description
   Text
     Compute the j-th reduced homology of C with coefficients in @TO (coefficientRing,SimplicialComplex)@ C.

   Example
    R=ZZ[x_0..x_5];
    D=simplicialComplex apply({{x_0, x_1, x_2}, {x_1, x_2, x_3}, {x_0, x_1, x_4}, {x_0, x_3, x_4}, {x_2, x_3, x_4}, {x_0, x_2, x_5}, {x_0, x_3, x_5}, {x_1, x_3, x_5}, {x_1, x_4, x_5}, {x_2, x_4, x_5}},face)
    prune homology(1,D)
  SeeAlso
    (homology,ZZ,SimplicialComplex,Ring)
   boundary
   (chainComplex,SimplicialComplex)
///

doc ///
  Key    
    (homology,ZZ,SimplicialComplex,Ring)
  Headline
    Compute the homology of a simplicial complex.
  Usage
    homology(j,C,R)
  Inputs
    j:ZZ
    C:SimplicialComplex
    R:Ring
  Outputs
    :Module
  Description
   Text
     Compute the j-th reduced homology of C with coefficients in R.

   Example
    R=ZZ[x_0..x_5];
    D=simplicialComplex apply({{x_0, x_1, x_2}, {x_1, x_2, x_3}, {x_0, x_1, x_4}, {x_0, x_3, x_4}, {x_2, x_3, x_4}, {x_0, x_2, x_5}, {x_0, x_3, x_5}, {x_1, x_3, x_5}, {x_1, x_4, x_5}, {x_2, x_4, x_5}},face)
    prune homology(1,D,ZZ)
    prune homology(1,D,QQ)
    prune homology(1,D,ZZ/2)
  SeeAlso
    (homology,ZZ,SimplicialComplex)
   boundary
   (chainComplex,SimplicialComplex)
///

doc ///
  Key    
    (homology,SimplicialComplex,Ring)
    (homology,Nothing,SimplicialComplex,Ring)
  Headline
    Compute the homology of a simplicial complex.
  Usage
    homology(C,R)
  Inputs
    C:SimplicialComplex
    R:Ring
  Outputs
    :GradedModule
  Description
   Text
     The graded module of reduced homologies of C with coefficients in R.

   Example
    R=ZZ[x_0..x_5];
    D=simplicialComplex apply({{x_0, x_1, x_2}, {x_1, x_2, x_3}, {x_0, x_1, x_4}, {x_0, x_3, x_4}, {x_2, x_3, x_4}, {x_0, x_2, x_5}, {x_0, x_3, x_5}, {x_1, x_3, x_5}, {x_1, x_4, x_5}, {x_2, x_4, x_5}},face)
    homology(D)
    homology(D,QQ)
    homology(D,ZZ/2)
  SeeAlso
    (homology,SimplicialComplex)
    (homology,ZZ,SimplicialComplex)
    (homology,ZZ,SimplicialComplex,Ring)
///

doc ///
  Key    
    (homology,SimplicialComplex)
    (homology,Nothing,SimplicialComplex)
  Headline
    Compute the homology of a simplicial complex.
  Usage
    homology C
  Inputs
    C:SimplicialComplex
  Outputs
    :GradedModule
  Description
   Text
     The graded module of reduced homologies of C with coefficients in R.

   Example
    R=ZZ[x_0..x_5];
    D=simplicialComplex apply({{x_0, x_1, x_2}, {x_1, x_2, x_3}, {x_0, x_1, x_4}, {x_0, x_3, x_4}, {x_2, x_3, x_4}, {x_0, x_2, x_5}, {x_0, x_3, x_5}, {x_1, x_3, x_5}, {x_1, x_4, x_5}, {x_2, x_4, x_5}},face)
    homology D
  SeeAlso
    (homology,SimplicialComplex,Ring)
    (homology,ZZ,SimplicialComplex)
    (homology,ZZ,SimplicialComplex,Ring)
///
